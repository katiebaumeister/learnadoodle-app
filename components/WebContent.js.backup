import React, { useState, useEffect, useRef } from 'react'
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TextInput,
  TouchableOpacity,
  Alert,
  Modal,
  Image,
  ActivityIndicator,
  Animated,
  Platform,
} from 'react-native'
import { Ionicons } from '@expo/vector-icons'
import { Clock, ArrowRight, UserCircle, Link, MapPin, Eye } from 'lucide-react'
import { supabase } from '../lib/supabase'
import DatePicker from 'react-datepicker'
import 'react-datepicker/dist/react-datepicker.css'
import SyllabusUpload from './SyllabusUpload'
import OpenAITest from './OpenAITest'
import AIChatModal from './AIChatModal'
import AIConversationTest from './AIConversationTest'
import CalendarPlanning from './CalendarPlanning'

import AddChildForm from './AddChildForm'
import AddOptions from './AddOptions'
import AddActivityForm from './AddActivityForm'
import StudentDetailsModal from './StudentDetailsModal'

import SubjectSelectForm from './SubjectSelectForm'
import { getSubjectRecommendations, processLiveClass, analyzeProgress, chatWithDoodleBot } from '../lib/aiProcessor.js'
import { AIConversationService } from '../lib/aiConversationService.js'
import { processDoodleMessage, executeTool } from '../lib/doodleAssistant.js'

export default function WebContent({ activeTab, activeSubtab, user, onChildAdded, navigation, showSyllabusUpload, onSyllabusProcessed, onCloseSyllabusUpload, onTabChange, pendingDoodlePrompt, onConsumeDoodlePrompt }) {
  // Create rotating animation for loading spinners
  const spinValue = useRef(new Animated.Value(0)).current;
  
  React.useEffect(() => {
    const spinAnimation = Animated.loop(
      Animated.timing(spinValue, {
        toValue: 1,
        duration: 1000,
        useNativeDriver: true,
      })
    );
    spinAnimation.start();
    
    return () => spinAnimation.stop();
  }, [spinValue]);
  
  const spin = spinValue.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });
  
  // Add CSS animation for loading spinner (web only)
  React.useEffect(() => {
    if (typeof window !== 'undefined') {
      const style = document.createElement('style');
      style.textContent = `
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
      `;
      document.head.appendChild(style);
      return () => document.head.removeChild(style);
    }
  }, []);

  // Avatar sources - static mapping for React Native
  const avatarSources = {
    prof1: require('../assets/prof1.png'),
    prof2: require('../assets/prof2.png'),
    prof3: require('../assets/prof3.png'),
    prof4: require('../assets/prof4.png'),
    prof5: require('../assets/prof5.png'),
    prof6: require('../assets/prof6.png'),
    prof7: require('../assets/prof7.png'),
    prof8: require('../assets/prof8.png'),
    prof9: require('../assets/prof9.png'),
    prof10: require('../assets/prof10.png'),
  }

  // Helper function to safely get avatar source
  const getAvatarSource = (avatarKey) => {
    try {
      return avatarSources[avatarKey] || avatarSources.prof1
    } catch (error) {
      console.warn('Avatar source error:', error)
      return avatarSources.prof1
    }
  }

  // State variables
  const [children, setChildren] = useState([])
  const [subjects, setSubjects] = useState([])
  const [activities, setActivities] = useState([])
  const [dailyTasks, setDailyTasks] = useState([])
  const [today] = useState(new Date().toISOString().split('T')[0])
  const [familyId, setFamilyId] = useState(null)
  
  // Calendar data caching
  const [calendarDataCache, setCalendarDataCache] = useState({})
  const [isCalendarDataLoaded, setIsCalendarDataLoaded] = useState(false)
  const [calendarDataLoading, setCalendarDataLoading] = useState(false)

  // Add child form state
  const [addChildName, setAddChildName] = useState('')
  const [addChildAge, setAddChildAge] = useState('')
  const [addChildGrade, setAddChildGrade] = useState('')
  const [addChildInterests, setAddChildInterests] = useState('')
  const [addChildStandards, setAddChildStandards] = useState('')
  const [addChildStyle, setAddChildStyle] = useState('')
  const [addChildCollegeBound, setAddChildCollegeBound] = useState(false)
  const [showSubjectSelectForChild, setShowSubjectSelectForChild] = useState(null)
  const [addChildAvatar, setAddChildAvatar] = useState('prof1')
  const [isAddingChild, setIsAddingChild] = useState(false)

  // DoodleBot state
  const [doodleMessages, setDoodleMessages] = useState([])
  const [doodleLoading, setDoodleLoading] = useState(false)
  const [doodleInput, setDoodleInput] = useState('')
  const [doodleConversationId, setDoodleConversationId] = useState(null)
  const [selectedChildId, setSelectedChildId] = useState(null)
  const [tasksData, setTasksData] = useState({ todo: [], inProgress: [], done: [] })
  const [progressData, setProgressData] = useState({ yearLabel: '', start: '', end: '', percent: 0 })
  const [todaysLearning, setTodaysLearning] = useState([])
  const [loadingLearning, setLoadingLearning] = useState(true)
  const [track, setTrack] = useState([])
  const [selectedStudent, setSelectedStudent] = useState(null)
  const [showHolidays, setShowHolidays] = useState(true)
  const [showAISuggestions, setShowAISuggestions] = useState(false)
  const [showComingSoonModal, setShowComingSoonModal] = useState(false)
  const [miniCalendarMonth, setMiniCalendarMonth] = useState(new Date())
  const [selectedChildren, setSelectedChildren] = useState([])
  const [searchQuery, setSearchQuery] = useState('')
  const [searchResults, setSearchResults] = useState([])
  const [isSearching, setIsSearching] = useState(false)
  const [showStudentModal, setShowStudentModal] = useState(false)
  const [selectedEvent, setSelectedEvent] = useState(null)
  const [isEditingEvent, setIsEditingEvent] = useState(false)
  const [editedEventData, setEditedEventData] = useState({})
  const [showActionMenu, setShowActionMenu] = useState(false)
  const [showStatusMenu, setShowStatusMenu] = useState(false)
  const [showAssigneeMenu, setShowAssigneeMenu] = useState(false)
  const [showPriorityMenu, setShowPriorityMenu] = useState(false)

  const [showTagsInput, setShowTagsInput] = useState(false)
  const [newTag, setNewTag] = useState('')
  const [isSaving, setIsSaving] = useState(false)

  const [editingTimeEstimate, setEditingTimeEstimate] = useState(false)
  const [tempTimeEstimate, setTempTimeEstimate] = useState('')
  const [editingDueDate, setEditingDueDate] = useState(false)
  const [tempDueDate, setTempDueDate] = useState('')
  const [editingScheduledDate, setEditingScheduledDate] = useState(false)
  const [tempScheduledDate, setTempScheduledDate] = useState('')
  const [editingTitle, setEditingTitle] = useState(false)
  const [tempTitle, setTempTitle] = useState('')
  const [editingAssignee, setEditingAssignee] = useState(false)
  const [tempAssignee, setTempAssignee] = useState([])
  const [editingStatus, setEditingStatus] = useState(false)
  const [tempStatus, setTempStatus] = useState('')
  const [editingScheduledTime, setEditingScheduledTime] = useState(false)
  const [tempScheduledTime, setTempScheduledTime] = useState('')
  const [editingFinishTime, setEditingFinishTime] = useState(false)
  const [tempFinishTime, setTempFinishTime] = useState('')



  // Right Pane New Event State
  const [showNewEventForm, setShowNewEventForm] = useState(false);
  const [newEventFormData, setNewEventFormData] = useState({
    title: '',
    description: '',
    scheduledDate: '',
    scheduledTime: '',
    dueDate: '',
    finishTime: '',
    timeEstimate: '',
    assignees: [],
    status: 'planned'
  });
  const [holidayDateRange, setHolidayDateRange] = useState({
    startDate: '',
    endDate: '',
    isRange: false
  });
  const [holidayRepeat, setHolidayRepeat] = useState({
    enabled: false,
    frequency: 'weekly', // daily, weekly, biweekly, monthly, yearly
    interval: 1
  });
  const [newEventType, setNewEventType] = useState('lesson');
  const [showEventTypeDropdown, setShowEventTypeDropdown] = useState(false);
  const [showStatusDropdown, setShowStatusDropdown] = useState(false);

  // Close all dropdowns when clicking outside
  const closeAllDropdowns = () => {
    setShowActionMenu(false)
    setShowStatusMenu(false)
    setShowAssigneeMenu(false)
    setShowPriorityMenu(false)
    setShowTagsInput(false)
    setEditingTimeEstimate(false)
    setEditingDueDate(false)
    setEditingScheduledDate(false)
    setEditingTitle(false)
    setEditingAssignee(false)
    setEditingStatus(false)
    setEditingScheduledTime(false)
    setEditingFinishTime(false)
    setShowEventTypeDropdown(false)
    setShowStatusDropdown(false)
  }

  // Close dropdowns when event changes
  useEffect(() => {
    closeAllDropdowns()
  }, [selectedEvent])

  // Calculate finish time based on scheduled time and time estimate
  const calculateFinishTime = (scheduledTime, timeEstimateMinutes) => {
    if (!scheduledTime || !timeEstimateMinutes || timeEstimateMinutes <= 0) {
      return null
    }

    try {
      // Parse the scheduled time (handle both "9:00 AM" and "09:00" formats)
      let hours, minutes
      const timeMatch = scheduledTime.match(/(\d{1,2}):(\d{2})(?:\s*(AM|PM))?/i)
      
      if (!timeMatch) {
        return null
      }

      hours = parseInt(timeMatch[1])
      minutes = parseInt(timeMatch[2])
      const period = timeMatch[3]?.toUpperCase()

      // Convert to 24-hour format if needed
      if (period === 'PM' && hours !== 12) {
        hours += 12
      } else if (period === 'AM' && hours === 12) {
        hours = 0
      }

      // Add the time estimate
      const totalMinutes = hours * 60 + minutes + timeEstimateMinutes
      const finishHours = Math.floor(totalMinutes / 60)
      const finishMinutes = totalMinutes % 60

      // Convert back to 12-hour format for display
      let displayHours = finishHours
      const displayPeriod = finishHours >= 12 ? 'PM' : 'AM'
      
      if (finishHours > 12) {
        displayHours = finishHours - 12
      } else if (finishHours === 0) {
        displayHours = 12
      }

      return `${displayHours}:${finishMinutes.toString().padStart(2, '0')} ${displayPeriod}`
    } catch (error) {
      console.error('Error calculating finish time:', error)
      return null
    }
  }

  // Calculate time estimate based on scheduled time and finish time
  const calculateTimeEstimate = (scheduledTime, finishTime) => {
    if (!scheduledTime || !finishTime) {
      return null
    }

    try {
      // Parse the scheduled time
      let startHours, startMinutes
      const startMatch = scheduledTime.match(/(\d{1,2}):(\d{2})(?:\s*(AM|PM))?/i)
      
      if (!startMatch) {
        return null
      }

      startHours = parseInt(startMatch[1])
      startMinutes = parseInt(startMatch[2])
      const startPeriod = startMatch[3]?.toUpperCase()

      // Convert start time to 24-hour format
      if (startPeriod === 'PM' && startHours !== 12) {
        startHours += 12
      } else if (startPeriod === 'AM' && startHours === 12) {
        startHours = 0
      }

      // Parse the finish time
      let finishHours, finishMinutes
      const finishMatch = finishTime.match(/(\d{1,2}):(\d{2})(?:\s*(AM|PM))?/i)
      
      if (!finishMatch) {
        return null
      }

      finishHours = parseInt(finishMatch[1])
      finishMinutes = parseInt(finishMatch[2])
      const finishPeriod = finishMatch[3]?.toUpperCase()

      // Convert finish time to 24-hour format
      if (finishPeriod === 'PM' && finishHours !== 12) {
        finishHours += 12
      } else if (finishPeriod === 'AM' && finishHours === 12) {
        finishHours = 0
      }

      // Calculate the difference in minutes
      const startTotalMinutes = startHours * 60 + startMinutes
      const finishTotalMinutes = finishHours * 60 + finishMinutes
      
      let diffMinutes = finishTotalMinutes - startTotalMinutes
      
      // Handle overnight events (finish time is next day)
      if (diffMinutes < 0) {
        diffMinutes += 24 * 60 // Add 24 hours
      }

      return diffMinutes > 0 ? diffMinutes : null
    } catch (error) {
      console.error('Error calculating time estimate:', error)
      return null
    }
  }

  // Right Pane New Event Functions
  const openNewEventForm = () => {
    setShowNewEventForm(true);
    setSelectedEvent(null);
    setNewEventType('lesson');
    setShowEventTypeDropdown(false);
    setNewEventFormData({
      title: '',
      description: '',
      scheduledDate: '',
      scheduledTime: '',
      dueDate: '',
      finishTime: '',
      timeEstimate: '',
      assignees: [],
      status: 'planned'
    });
  };

  const closeNewEventForm = () => {
    setShowNewEventForm(false);
    setSelectedEvent(null);
    setNewEventType('lesson');
    setShowEventTypeDropdown(false);
    setHolidayDateRange({
      startDate: '',
      endDate: '',
      isRange: false
    });
    setHolidayRepeat({
      enabled: false,
      frequency: 'weekly',
      interval: 1
    });
  };

  const saveNewEventFromForm = async () => {
    setIsSaving(true);
    try {
      let result;
      
      if (newEventType === 'lesson' || newEventType === 'activity') {
        // Use manually entered finish time or calculate based on time estimate
        const timeEstimate = parseInt(newEventFormData.timeEstimate) || 0
        const finishTime = newEventFormData.finishTime || calculateFinishTime(newEventFormData.scheduledTime, timeEstimate)
        
        const eventData = {
          family_id: familyId,
          title: newEventFormData.title,
          description: newEventFormData.description,
          scheduled_date: newEventFormData.scheduledDate,
          scheduled_time: newEventFormData.scheduledTime,
          due_date: newEventFormData.dueDate,
          minutes: timeEstimate,
          finish_time: finishTime,
          child_name: JSON.stringify(newEventFormData.assignees),
          status: newEventFormData.status,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        };

        // Save to activity_instances table for lessons and activities
        result = await supabase
          .from('activity_instances')
          .insert([eventData]);
      } else if (newEventType === 'holiday') {
        // Handle holiday creation with date range and repetition
        const holidaysToCreate = [];
        
        if (holidayDateRange.isRange) {
          // Create multiple holidays for date range
          const startDate = new Date(holidayDateRange.startDate);
          const endDate = new Date(holidayDateRange.endDate);
          
          for (let date = new Date(startDate); date <= endDate; date.setDate(date.getDate() + 1)) {
            const dateStr = date.toISOString().split('T')[0];
            const holidayData = {
              family_id: familyId,
              holiday_name: newEventFormData.title,
              holiday_date: dateStr,
              description: newEventFormData.description,
              is_proposed: false,
              created_at: new Date().toISOString(),
              repeat_config: holidayRepeat.enabled ? JSON.stringify(holidayRepeat) : null
            };
            holidaysToCreate.push(holidayData);
          }
        } else {
          // Single holiday
          const holidayData = {
            family_id: familyId,
            holiday_name: newEventFormData.title,
            holiday_date: newEventFormData.scheduledDate,
            description: newEventFormData.description,
            is_proposed: false,
            created_at: new Date().toISOString(),
            repeat_config: holidayRepeat.enabled ? JSON.stringify(holidayRepeat) : null
          };
          holidaysToCreate.push(holidayData);
        }

        // Save all holidays to the holidays table
        result = await supabase
          .from('holidays')
          .insert(holidaysToCreate);
      }

      if (result.error) {
        throw result.error;
      }

      // Refresh calendar data
      await refreshCalendarData();
      closeNewEventForm();
      Alert.alert('Success', 'Event created successfully!');
    } catch (error) {
      console.error('Error saving new event:', error);
      Alert.alert('Error', 'Failed to create event. Please try again.');
    } finally {
      setIsSaving(false);
    }
  };

  // Save event changes to Supabase
  const saveEventChanges = async (eventId, changes) => {
    try {
      console.log('Attempting to save changes:', { eventId, changes })
      
      // For lesson events (activity_instances), update the instance table
      // For activity events (activities), update the activities table
      const tableName = selectedEvent?.type === 'lesson' ? 'activity_instances' : 'activities'
      
      // First, let's check what columns exist in the target table
      const { data: tableInfo, error: tableError } = await supabase
        .from(tableName)
        .select('*')
        .limit(1)
      
      if (tableError) {
        console.error('Error checking table structure:', tableError)
      } else {
        console.log(`${tableName} table columns:`, Object.keys(tableInfo[0] || {}))
      }
      
      const { error } = await supabase
        .from(tableName)
        .update(changes)
        .eq('id', eventId)
      
      if (error) {
        console.error('Error saving event changes:', error)
        console.error('Error details:', {
          code: error.code,
          message: error.message,
          details: error.details,
          hint: error.hint
        })
        throw error
      }
      
      console.log('Successfully saved changes to database')
      return { success: true }
    } catch (error) {
      console.error('Failed to save event changes:', error)
      return { success: false, error: error.message }
    }
  }

  // Handle status change with save
  const handleStatusChange = async (newStatus) => {
    if (!selectedEvent?.id) {
      console.error('No event ID for status change')
      return
    }

    // Check if this is a fallback event (string ID starting with 'fallback-')
    if (typeof selectedEvent.id === 'string' && selectedEvent.id.startsWith('fallback-')) {
      console.log('Cannot save changes to fallback events')
      if (typeof window !== 'undefined' && window.alert) {
        window.alert('Cannot save changes to sample events. Please select a real event from your calendar.')
      }
      return
    }

    // Check if this is a lesson event (activity_instances) - these can be updated
    if (selectedEvent.type === 'lesson') {
      console.log('Updating status for lesson event (activity_instance)')
      // Continue with the update - lesson events can have their status changed
    }

    setIsSaving(true)
    try {
      const result = await saveEventChanges(selectedEvent.id, { status: newStatus })
      
      if (result.success) {
        setSelectedEvent({
          ...selectedEvent, 
          data: {
            ...selectedEvent.data,
            status: newStatus
          }
        })
        setShowStatusMenu(false)
        // Success - no dialog needed
      } else {
        // Show error feedback
        if (typeof window !== 'undefined' && window.alert) {
          window.alert(`Failed to update status: ${result.error}`)
        }
      }
    } catch (error) {
      console.error('Error updating status:', error)
      if (typeof window !== 'undefined' && window.alert) {
        window.alert(`Error updating status: ${error.message}`)
      }
    } finally {
      setIsSaving(false)
    }
  }

  // Handle assignee change with save (supports multiple assignees)
  const handleAssigneeChange = async (assignee, action = 'toggle') => {
    if (!selectedEvent?.id) {
      console.error('No event ID for assignee change')
      return
    }

    // Check if this is a fallback event (string ID starting with 'fallback-')
    if (typeof selectedEvent.id === 'string' && selectedEvent.id.startsWith('fallback-')) {
      console.log('Cannot save changes to fallback events')
      if (typeof window !== 'undefined' && window.alert) {
        window.alert('Cannot save changes to sample events. Please select a real event from your calendar.')
      }
      return
    }

    // Check if this is a lesson event (activity_instances) - these can be updated
    if (selectedEvent.type === 'lesson') {
      console.log('Updating assignee for lesson event (activity_instance)')
      // Continue with the update - lesson events can have their assignee changed
    }

    setIsSaving(true)
        try {
      console.log('Event ID for save:', selectedEvent.id, 'Event type:', typeof selectedEvent.id)
      
      // Get current assignees
      const currentAssignees = getCurrentAssignees()
      let newAssignees = []
      
      if (action === 'toggle') {
        // Toggle assignee in/out of the list
        if (currentAssignees.includes(assignee)) {
          newAssignees = currentAssignees.filter(a => a !== assignee)
        } else {
          newAssignees = [...currentAssignees, assignee]
        }
      } else if (action === 'set') {
        // Set single assignee
        newAssignees = [assignee]
      } else if (action === 'clear') {
        // Clear all assignees
        newAssignees = []
      }
      
      // Save as JSON array to child_name field
      console.log('Saving assignees:', newAssignees, 'for event:', selectedEvent.id)
      const result = await saveEventChanges(selectedEvent.id, { 
        child_name: JSON.stringify(newAssignees)
      })
      
      if (result.success) {
        const updatedEvent = {
          ...selectedEvent, 
          data: {
            ...selectedEvent.data,
            child_name: JSON.stringify(newAssignees)
          }
        }
        setSelectedEvent(updatedEvent)
        setShowAssigneeMenu(false)
        // Success - no dialog needed
      } else {
        // Show error feedback
        if (typeof window !== 'undefined' && window.alert) {
          window.alert(`Failed to update assignee: ${result.error}`)
        }
      }
    } catch (error) {
      console.error('Error updating assignee:', error)
      if (typeof window !== 'undefined' && window.alert) {
        window.alert(`Error updating assignee: ${error.message}`)
      }
    } finally {
      setIsSaving(false)
    }
  }

  // Handle description change with save
  const handleDescriptionChange = async (newDescription) => {
    if (!selectedEvent?.id) {
      console.error('No event ID for description change')
      return
    }

    // Check if this is a fallback event (string ID starting with 'fallback-'))
    if (typeof selectedEvent.id === 'string' && selectedEvent.id.startsWith('fallback-')) {
      console.log('Cannot save changes to fallback events')
      if (typeof window !== 'undefined' && window.alert) {
        window.alert('Cannot save changes to sample events. Please select a real event from your calendar.')
      }
      return
    }

    setIsSaving(true)
    try {
      const result = await saveEventChanges(selectedEvent.id, { description: newDescription })
      
      if (result.success) {
        setSelectedEvent({
          ...selectedEvent, 
          data: {
            ...selectedEvent.data,
            description: newDescription
          }
        })
        // Success - no dialog needed
      } else {
        // Show error feedback
        if (typeof window !== 'undefined' && window.alert) {
          window.alert(`Failed to update description: ${result.error}`)
        }
      }
    } catch (error) {
      console.error('Error updating description:', error)
      if (typeof window !== 'undefined' && window.alert) {
        window.alert(`Error updating description: ${error.message}`)
      }
    } finally {
      setIsSaving(false)
    }
  }

  // Helper function to get current assignees
  const getCurrentAssignees = () => {
    // Handle both old single assignee and new JSON array format
    // Check child_name first (new format)
    if (selectedEvent.data?.child_name) {
      try {
        // Try to parse as JSON array
        const parsed = JSON.parse(selectedEvent.data.child_name)
        if (Array.isArray(parsed)) {
          return parsed
        } else {
          // Single assignee value
          return [selectedEvent.data.child_name]
        }
      } catch (e) {
        // Not JSON, treat as single assignee
        return [selectedEvent.data.child_name]
      }
    } else if (selectedEvent.assignees && selectedEvent.assignees.length > 0) {
      return selectedEvent.assignees
    } else if (selectedEvent.data?.assignee) {
      try {
        // Try to parse as JSON array
        const parsed = JSON.parse(selectedEvent.data.assignee)
        if (Array.isArray(parsed)) {
          return parsed
        } else {
          // Single assignee value
          return [selectedEvent.data.assignee]
        }
      } catch (e) {
        // Not JSON, treat as single assignee
        return [selectedEvent.data.assignee]
      }
    } else if (selectedEvent.assignee) {
      try {
        // Try to parse as JSON array
        const parsed = JSON.parse(selectedEvent.assignee)
        if (Array.isArray(parsed)) {
          return parsed
        } else {
          // Single assignee value
          return [selectedEvent.assignee]
        }
      } catch (e) {
        // Not JSON, treat as single assignee
        return [selectedEvent.assignee]
      }
    }
    return []
  }

  // Helper functions for status and priority
  const getStatusColor = (status) => {
    switch (status) {
      case 'planned': return '#3b82f6'  // Blue for To Do
      case 'in_progress': return '#f59e0b'  // Orange for In Progress
      case 'completed': return '#10b981'  // Green for Completed
      case 'skipped': return '#6b7280'  // Gray for Skipped
      default: return '#3b82f6'
    }
  }

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'Low': return '#10b981'
      case 'Medium': return '#f59e0b'
      case 'High': return '#dc2626'
      case 'Urgent': return '#7c2d12'
      default: return '#f59e0b'
    }
  }

  const getPriorityIcon = (priority) => {
    switch (priority) {
      case 'Low': return 'ðŸŸ¢'
      case 'Medium': return 'ðŸŸ¡'
      case 'High': return 'ðŸ”´'
      case 'Urgent': return 'ðŸš¨'
      default: return 'ðŸŸ¡'
    }
  }

  // Syllabus upload state
  const [processedSyllabi, setProcessedSyllabi] = useState([])
  const [showSyllabusModal, setShowSyllabusModal] = useState(false)





  // Handle time estimate editing
  const handleTimeEstimateEdit = () => {
    setTempTimeEstimate(selectedEvent.data?.minutes || selectedEvent.estimateMinutes || '')
    setEditingTimeEstimate(true)
  }

  const handleTimeEstimateSave = async () => {
    if (!selectedEvent?.id) {
      console.error('No event ID for time estimate change')
      return
    }

    if (typeof selectedEvent.id === 'string' && selectedEvent.id.startsWith('fallback-')) {
      console.log('Cannot save changes to fallback events')
      return
    }

    const newEstimate = parseInt(tempTimeEstimate, 10)
    if (isNaN(newEstimate) || newEstimate < 0) {
      if (typeof window !== 'undefined' && window.alert) {
        window.alert('Please enter a valid number of minutes (0 or greater)')
      }
      return
    }

    setIsSaving(true)
    try {
      // Calculate finish time based on scheduled time and new estimate
      const currentScheduledTime = selectedEvent.data?.scheduled_time || selectedEvent.scheduled_time
      const finishTime = calculateFinishTime(currentScheduledTime, newEstimate)
      
      const result = await saveEventChanges(selectedEvent.id, { 
        minutes: newEstimate,
        finish_time: finishTime
      })
      
      if (result.success) {
        setSelectedEvent({
          ...selectedEvent, 
          data: {
            ...selectedEvent.data,
            minutes: newEstimate,
            finish_time: finishTime
          }
        })
        setEditingTimeEstimate(false)
        // Success - no dialog needed
      } else {
        if (typeof window !== 'undefined' && window.alert) {
          window.alert(`Failed to update time estimate: ${result.error}`)
        }
      }
    } catch (error) {
      console.error('Error updating time estimate:', error)
      if (typeof window !== 'undefined' && window.alert) {
        window.alert(`Error updating time estimate: ${error.message}`)
      }
    } finally {
      setIsSaving(false)
    }
  }

  const handleTimeEstimateCancel = () => {
    setEditingTimeEstimate(false)
    setTempTimeEstimate('')
  }

  // Handle due date editing
  const handleDueDateEdit = () => {
    const currentDueDate = selectedEvent.data?.due_date || ''
    if (currentDueDate) {
      // Convert YYYY-MM-DD to MM/DD/YY
      const [year, month, day] = currentDueDate.split('-')
      const shortYear = year.substring(2) // Get last 2 digits
      setTempDueDate(`${month}/${day}/${shortYear}`)
    } else {
      setTempDueDate('')
    }
    setEditingDueDate(true)
  }

  const handleDueDateSave = async () => {
    if (!selectedEvent?.id) {
      console.error('No event ID for due date change')
      return
    }

    if (typeof selectedEvent.id === 'string' && selectedEvent.id.startsWith('fallback-')) {
      console.log('Cannot save changes to fallback events')
      return
    }

    // Convert MM/DD/YY to YYYY-MM-DD format
    let finalDueDate = null
    if (tempDueDate.trim() !== '') {
      // Validate MM/DD/YY format
      if (!/^\d{2}\/\d{2}\/\d{2}$/.test(tempDueDate)) {
        if (typeof window !== 'undefined' && window.alert) {
          window.alert('Invalid date format. Please use MM/DD/YY (e.g., 01/15/25)')
        }
        return
      }
      
      // Convert MM/DD/YY to YYYY-MM-DD
      const [month, day, year] = tempDueDate.split('/')
      const fullYear = '20' + year // Assume 20xx for 2-digit years
      finalDueDate = `${fullYear}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`
    }

    setIsSaving(true)
    try {
      const result = await saveEventChanges(selectedEvent.id, { due_date: finalDueDate })
      
      if (result.success) {
        setSelectedEvent({
          ...selectedEvent, 
          data: {
            ...selectedEvent.data,
            due_date: finalDueDate
          }
        })
        setEditingDueDate(false)
        // Success - no dialog needed
      } else {
        if (typeof window !== 'undefined' && window.alert) {
          window.alert(`Failed to update due date: ${result.error}`)
        }
      }
    } catch (error) {
      console.error('Error updating due date:', error)
      if (typeof window !== 'undefined' && window.alert) {
        window.alert(`Error updating due date: ${error.message}`)
      }
    } finally {
      setIsSaving(false)
    }
  }

  const handleDueDateCancel = () => {
    setEditingDueDate(false)
    setTempDueDate('')
  }

  // Handle scheduled date editing
  const handleScheduledDateEdit = () => {
    const currentScheduledDate = selectedEvent.data?.scheduled_date || ''
    if (currentScheduledDate) {
      // Convert YYYY-MM-DD to MM/DD/YY
      const [year, month, day] = currentScheduledDate.split('-')
      const shortYear = year.substring(2) // Get last 2 digits
      setTempScheduledDate(`${month}/${day}/${shortYear}`)
    } else {
      setTempScheduledDate('')
    }
    setEditingScheduledDate(true)
  }

  const handleScheduledDateSave = async () => {
    if (!selectedEvent?.id) {
      console.error('No event ID for scheduled date change')
      return
    }

    if (typeof selectedEvent.id === 'string' && selectedEvent.id.startsWith('fallback-')) {
      console.log('Cannot save changes to fallback events')
      return
    }

    // Convert MM/DD/YY to YYYY-MM-DD format
    let finalScheduledDate = null
    if (tempScheduledDate.trim() !== '') {
      // Validate MM/DD/YY format
      if (!/^\d{2}\/\d{2}\/\d{2}$/.test(tempScheduledDate)) {
        if (typeof window !== 'undefined' && window.alert) {
          window.alert('Invalid date format. Please use MM/DD/YY (e.g., 01/15/25)')
        }
        return
      }
      
      // Convert MM/DD/YY to YYYY-MM-DD
      const [month, day, year] = tempScheduledDate.split('/')
      const fullYear = '20' + year // Assume 20xx for 2-digit years
      finalScheduledDate = `${fullYear}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`
    }

    setIsSaving(true)
    try {
      const result = await saveEventChanges(selectedEvent.id, { scheduled_date: finalScheduledDate })
      
      if (result.success) {
        setSelectedEvent({
          ...selectedEvent, 
          data: {
            ...selectedEvent.data,
            scheduled_date: finalScheduledDate
          }
        })
        setEditingScheduledDate(false)
        // Success - no dialog needed
      } else {
        if (typeof window !== 'undefined' && window.alert) {
          window.alert(`Failed to update scheduled date: ${result.error}`)
        }
      }
    } catch (error) {
      console.error('Error updating scheduled date:', error)
      if (typeof window !== 'undefined' && window.alert) {
        window.alert(`Error updating scheduled date: ${error.message}`)
      }
    } finally {
      setIsSaving(false)
    }
  }

  const handleScheduledDateCancel = () => {
    setEditingScheduledDate(false)
    setTempScheduledDate('')
  }

  // Handle title editing
  const handleTitleEdit = () => {
    const currentTitle = selectedEvent.data?.title || selectedEvent.title || ''
    setTempTitle(currentTitle)
    setEditingTitle(true)
  }

  const handleTitleSave = async () => {
    if (!selectedEvent?.id) {
      console.error('No event ID for title change')
      return
    }

    if (typeof selectedEvent.id === 'string' && selectedEvent.id.startsWith('fallback-')) {
      console.log('Cannot save changes to fallback events')
      return
    }

    const finalTitle = tempTitle.trim() || null

    setIsSaving(true)
    try {
      const result = await saveEventChanges(selectedEvent.id, { title: finalTitle })
      
      if (result.success) {
        setSelectedEvent({
          ...selectedEvent, 
          data: {
            ...selectedEvent.data,
            title: finalTitle
          }
        })
        setEditingTitle(false)
        // Success - no dialog needed
      } else {
        if (typeof window !== 'undefined' && window.alert) {
          window.alert(`Failed to update title: ${result.error}`)
        }
      }
    } catch (error) {
      console.error('Error updating title:', error)
      if (typeof window !== 'undefined' && window.alert) {
        window.alert(`Error updating title: ${error.message}`)
      }
    } finally {
      setIsSaving(false)
    }
  }

  const handleTitleCancel = () => {
    setEditingTitle(false)
    setTempTitle('')
  }

  // Handle assignee inline editing
  const handleAssigneeEdit = () => {
    const currentAssignees = getCurrentAssignees()
    setTempAssignee([...currentAssignees])
    setEditingAssignee(true)
  }

  const handleAssigneeSave = async () => {
    if (!selectedEvent?.id) {
      console.error('No event ID for assignee change')
      return
    }

    if (typeof selectedEvent.id === 'string' && selectedEvent.id.startsWith('fallback-')) {
      console.log('Cannot save changes to fallback events')
      return
    }

    setIsSaving(true)
    try {
      const result = await saveEventChanges(selectedEvent.id, { 
        child_name: JSON.stringify(tempAssignee)
      })
      
      if (result.success) {
        setSelectedEvent({
          ...selectedEvent, 
          data: {
            ...selectedEvent.data,
            child_name: JSON.stringify(tempAssignee)
          }
        })
        setEditingAssignee(false)
      } else {
        if (typeof window !== 'undefined' && window.alert) {
          window.alert(`Failed to update assignee: ${result.error}`)
        }
      }
    } catch (error) {
      console.error('Error updating assignee:', error)
      if (typeof window !== 'undefined' && window.alert) {
        window.alert(`Error updating assignee: ${error.message}`)
      }
    } finally {
      setIsSaving(false)
    }
  }

  const handleAssigneeCancel = () => {
    setEditingAssignee(false)
    setTempAssignee([])
  }

  // Handle status inline editing
  const handleStatusEdit = () => {
    const currentStatus = selectedEvent.data?.status || 'planned'
    setTempStatus(currentStatus)
    setEditingStatus(true)
  }

  const handleStatusSave = async () => {
    if (!selectedEvent?.id) {
      console.error('No event ID for status change')
      return
    }

    if (typeof selectedEvent.id === 'string' && selectedEvent.id.startsWith('fallback-')) {
      console.log('Cannot save changes to fallback events')
      return
    }

    setIsSaving(true)
    try {
      const result = await saveEventChanges(selectedEvent.id, { status: tempStatus })
      
      if (result.success) {
        setSelectedEvent({
          ...selectedEvent, 
          data: {
            ...selectedEvent.data,
            status: tempStatus
          }
        })
        setEditingStatus(false)
      } else {
        if (typeof window !== 'undefined' && window.alert) {
          window.alert(`Failed to update status: ${result.error}`)
        }
      }
    } catch (error) {
      console.error('Error updating status:', error)
      if (typeof window !== 'undefined' && window.alert) {
        window.alert(`Error updating status: ${error.message}`)
      }
    } finally {
      setIsSaving(false)
    }
  }

  const handleStatusCancel = () => {
    setEditingStatus(false)
    setTempStatus('')
  }

  // Handle scheduled time inline editing
  const handleScheduledTimeEdit = () => {
    const currentTime = selectedEvent.data?.scheduled_time || ''
    // Convert time format for HTML time input (HH:MM)
    if (Platform.OS === 'web' && currentTime) {
      // Convert "9:00 AM" format to "09:00" format for HTML time input
      const timeMatch = currentTime.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i)
      if (timeMatch) {
        let hours = parseInt(timeMatch[1])
        const minutes = timeMatch[2]
        const period = timeMatch[3].toUpperCase()
        
        if (period === 'PM' && hours !== 12) {
          hours += 12
        } else if (period === 'AM' && hours === 12) {
          hours = 0
        }
        
        const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes}`
        setTempScheduledTime(formattedTime)
      } else {
        setTempScheduledTime(currentTime)
      }
    } else {
      setTempScheduledTime(currentTime)
    }
    setEditingScheduledTime(true)
  }

  const handleScheduledTimeSave = async () => {
    if (!selectedEvent?.id) {
      console.error('No event ID for scheduled time change')
      return
    }

    if (typeof selectedEvent.id === 'string' && selectedEvent.id.startsWith('fallback-')) {
      console.log('Cannot save changes to fallback events')
      return
    }

    // Convert time format for display (HH:MM to 12-hour format)
    let timeToSave = tempScheduledTime
    if (Platform.OS === 'web' && tempScheduledTime) {
      const timeMatch = tempScheduledTime.match(/^(\d{1,2}):(\d{2})$/)
      if (timeMatch) {
        let hours = parseInt(timeMatch[1])
        const minutes = timeMatch[2]
        
        const period = hours >= 12 ? 'PM' : 'AM'
        if (hours > 12) {
          hours -= 12
        } else if (hours === 0) {
          hours = 12
        }
        
        timeToSave = `${hours}:${minutes} ${period}`
      }
    }

    setIsSaving(true)
    try {
      // Calculate finish time based on new scheduled time and current estimate
      const currentEstimate = selectedEvent.data?.minutes || selectedEvent.estimateMinutes || 0
      const finishTime = calculateFinishTime(timeToSave, currentEstimate)
      
      const result = await saveEventChanges(selectedEvent.id, { 
        scheduled_time: timeToSave,
        finish_time: finishTime
      })
      
      if (result.success) {
        setSelectedEvent({
          ...selectedEvent, 
          data: {
            ...selectedEvent.data,
            scheduled_time: tempScheduledTime,
            finish_time: finishTime
          }
        })
        setEditingScheduledTime(false)
      } else {
        if (typeof window !== 'undefined' && window.alert) {
          window.alert(`Failed to update scheduled time: ${result.error}`)
        }
      }
    } catch (error) {
      console.error('Error updating scheduled time:', error)
      if (typeof window !== 'undefined' && window.alert) {
        window.alert(`Error updating scheduled time: ${error.message}`)
      }
    } finally {
      setIsSaving(false)
    }
  }

  const handleScheduledTimeCancel = () => {
    setEditingScheduledTime(false)
    setTempScheduledTime('')
  }

  // Handle finish time editing
  const handleFinishTimeEdit = () => {
    const currentFinishTime = selectedEvent.data?.finish_time || ''
    if (currentFinishTime) {
      // Convert "10:30 AM" format to "10:30" format for HTML time input
      const timeMatch = currentFinishTime.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i)
      if (timeMatch) {
        let hours = parseInt(timeMatch[1])
        const minutes = timeMatch[2]
        const period = timeMatch[3].toUpperCase()
        
        // Convert to 24-hour format
        if (period === 'PM' && hours !== 12) {
          hours += 12
        } else if (period === 'AM' && hours === 12) {
          hours = 0
        }
        
        const time24Hour = `${hours.toString().padStart(2, '0')}:${minutes}`
        setTempFinishTime(time24Hour)
      } else {
        setTempFinishTime(currentFinishTime)
      }
    } else {
      setTempFinishTime('')
    }
    setEditingFinishTime(true)
  }

  const handleFinishTimeSave = async () => {
    if (!selectedEvent?.id) {
      console.error('No event ID for finish time change')
      return
    }

    if (typeof selectedEvent.id === 'string' && selectedEvent.id.startsWith('fallback-')) {
      console.log('Cannot save changes to fallback events')
      return
    }

    // Convert time format for display (HH:MM to 12-hour format)
    let timeToSave = tempFinishTime
    if (Platform.OS === 'web' && tempFinishTime) {
      const timeMatch = tempFinishTime.match(/^(\d{1,2}):(\d{2})$/)
      if (timeMatch) {
        let hours = parseInt(timeMatch[1])
        const minutes = timeMatch[2]
        
        const period = hours >= 12 ? 'PM' : 'AM'
        if (hours > 12) {
          hours -= 12
        } else if (hours === 0) {
          hours = 12
        }
        
        timeToSave = `${hours}:${minutes} ${period}`
      }
    }

    setIsSaving(true)
    try {
      // Calculate time estimate based on new finish time and current scheduled time
      const currentScheduledTime = selectedEvent.data?.scheduled_time || selectedEvent.scheduled_time
      const calculatedTimeEstimate = calculateTimeEstimate(currentScheduledTime, timeToSave)
      
      const result = await saveEventChanges(selectedEvent.id, { 
        finish_time: timeToSave,
        minutes: calculatedTimeEstimate
      })
      
      if (result.success) {
        setSelectedEvent({
          ...selectedEvent, 
          data: {
            ...selectedEvent.data,
            finish_time: timeToSave,
            minutes: calculatedTimeEstimate
          }
        })
        setEditingFinishTime(false)
      } else {
        if (typeof window !== 'undefined' && window.alert) {
          window.alert(`Failed to update finish time: ${result.error}`)
        }
      }
    } catch (error) {
      console.error('Error updating finish time:', error)
      if (typeof window !== 'undefined' && window.alert) {
        window.alert(`Error updating finish time: ${error.message}`)
      }
    } finally {
      setIsSaving(false)
    }
  }

  const handleFinishTimeCancel = () => {
    setEditingFinishTime(false)
    setTempFinishTime('')
  }

  // Fetch children on mount
  useEffect(() => {
    fetchChildren()
    fetchFamilyId()
    fetchTodaysLearning()
  }, [])

  const handleStudentPress = (studentData) => {
    setSelectedStudent(studentData)
    setShowStudentModal(true)
  }

  const handleCloseStudentModal = () => {
    setShowStudentModal(false)
    setSelectedStudent(null)
  }

  const handleDeleteChild = async (childId) => {
    try {
      console.log('=== DELETE CHILD PROCESS STARTED ===');
      console.log('Child ID to delete:', childId);
      console.log('Selected student:', selectedStudent);
      console.log('Family ID:', familyId);
      
      // NEW APPROACH: Delete the child first, then handle cleanup
      console.log('Using new approach: Delete child first, then cleanup...');
      
      // Step 1: Try to delete the child record directly (this might trigger CASCADE)
      console.log('Step 1: Attempting to delete the child record directly...');
      try {
        const { error: childDeleteError } = await supabase
          .from('children')
          .delete()
          .eq('id', childId);
        
        if (childDeleteError) {
          console.log('Direct child deletion failed:', childDeleteError.message);
          console.log('Will try alternative cleanup approach...');
        } else {
          console.log('SUCCESS: Child deleted directly!');
          // Refresh data and return early
          await fetchChildren();
          await fetchTodaysLearning();
          handleCloseStudentModal();
          
          // Show success message
          if (typeof window !== 'undefined' && window.alert) {
            window.alert('Child deleted successfully!');
          }
          return;
        }
      } catch (e) {
        console.log('Direct child deletion failed with exception:', e);
        console.log('Will try alternative cleanup approach...');
      }
      
      // Step 2: If direct deletion failed, try to identify and delete related records
      console.log('Step 2: Attempting to identify and delete related records...');
      
      try {
        // First, let's see what's actually in the track table for this family
        const { data: trackData, error: trackQueryError } = await supabase
          .from('track')
          .select('*')
          .limit(5);
        
        if (trackQueryError) {
          console.log('Could not query track table:', trackQueryError.message);
          console.log('This confirms the RLS policy issue with "request.jwt.claims.family_id"');
        } else {
          console.log('Track table structure:', trackData);
        }
        
        // Try to find any records that might reference this child
        const { data: subjectTrackData, error: subjectTrackQueryError } = await supabase
          .from('subject_track')
          .select('*')
          .limit(5);
        
        if (subjectTrackQueryError) {
          console.log('Could not query subject_track table:', subjectTrackQueryError.message);
        } else {
          console.log('Subject_track table structure:', subjectTrackData);
        }
        
        // Try to work around the RLS issue by using a different approach
        console.log('Attempting to work around RLS policy issue...');
        
        // Try to delete track records using a more specific query that might bypass RLS
        try {
          const { error: trackDeleteError } = await supabase
            .from('track')
            .delete()
            .eq('id', '00000000-0000-0000-0000-000000000000'); // Try to delete a non-existent record first
          
          if (trackDeleteError) {
            console.log('Track deletion test failed:', trackDeleteError.message);
          } else {
            console.log('Track deletion test succeeded - RLS might allow some operations');
          }
        } catch (e) {
          console.log('Track deletion test failed with exception:', e);
        }
        
        // Try a different approach - attempt to delete by family_id if that column exists
        try {
          console.log('Attempting to delete track records by family_id...');
          const { error: familyTrackDeleteError } = await supabase
            .from('track')
            .delete()
            .eq('family_id', familyId);
          
          if (familyTrackDeleteError) {
            console.log('Family-based track deletion failed:', familyTrackDeleteError.message);
            console.log('This suggests the family_id column approach also has RLS issues');
          } else {
            console.log('Family-based track deletion succeeded!');
          }
        } catch (e) {
          console.log('Family-based track deletion failed with exception:', e);
        }
        
      } catch (e) {
        console.log('Table structure query failed:', e);
      }
      
            // Step 3: Try to delete from activities table
      console.log('Step 3: Attempting to delete from activities table...');
      try {
        const { error: activityError } = await supabase
          .from('activities')
          .delete()
          .eq('family_id', familyId);

        if (activityError) {
          console.log('Activities table deletion failed:', activityError.message);
          console.log('Continuing with other deletions...');
        } else {
          console.log('Step 3 completed: Activities deleted successfully');
        }
      } catch (e) {
        console.log('Activities table deletion failed with exception:', e);
        console.log('Continuing with other deletions...');
        console.log('This might be due to RLS policies, but continuing...');
      }

      // Step 4: Final attempt to delete the child
      console.log('Step 4: Final attempt to delete the child...');
      try {
        const { error } = await supabase
          .from('children')
          .delete()
          .eq('id', childId);

        if (error) {
          console.log('Final child deletion failed:', error.message);
          
          // Show error message to user
          if (typeof window !== 'undefined' && window.alert) {
            window.alert(`Failed to delete child: ${error.message}\n\nThis might be due to database constraints or permissions. Please contact support.`);
          }
          return;
        } else {
          console.log('SUCCESS: Child deleted on final attempt!');
        }
      } catch (e) {
        console.log('Final child deletion failed with exception:', e);
        
        // Show error message to user
        if (typeof window !== 'undefined' && window.alert) {
          window.alert(`Failed to delete child due to an error: ${e.message}\n\nPlease contact support.`);
        }
        return;
      }
      
      console.log('Step 4 completed: Child deleted successfully');
      console.log('=== DELETE CHILD PROCESS COMPLETED ===');
      
      // Refresh the children list and learning data
      console.log('Refreshing data...');
      await fetchChildren();
      await fetchTodaysLearning();
      
      // Close the modal
      handleCloseStudentModal();
      
      // Show success message
      if (typeof window !== 'undefined' && window.alert) {
        window.alert('Success: Child and all related data deleted successfully');
      } else {
        Alert.alert('Success', 'Child and all related data deleted successfully');
      }
      
    } catch (error) {
      console.error('=== DELETE CHILD PROCESS FAILED ===');
      console.error('Error deleting child:', error);
      if (typeof window !== 'undefined' && window.alert) {
        window.alert('Error: An error occurred while deleting the child');
      } else {
        Alert.alert('Error', 'An error occurred while deleting the child');
      }
    }
  };

  const fetchTodaysLearning = async () => {
    try {
      setLoadingLearning(true)
      
      // Get user's profile to find family_id
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      const { data: profile } = await supabase
        .from('profiles')
        .select('family_id')
        .eq('id', user.id)
        .single()

      if (!profile?.family_id) return

      // Get today's date and day of week
      const today = new Date()
      const dayOfWeek = today.getDay() // 0 = Sunday, 1 = Monday, etc.
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
      const todayName = dayNames[dayOfWeek]

      // Get learning tracks for today
      const { data: tracks, error: tracksError } = await supabase
        .from('subject_track')
        .select('id, name, class_schedule, study_days, roadmap, course_outline, status')
        .eq('family_id', profile.family_id)
        .eq('status', 'active')
      
      if (tracksError) throw tracksError

      // Also fetch track data for the sidebar
      const { data: trackData, error: trackDataError } = await supabase
        .from('track')
        .select('*')
        .eq('family_id', profile.family_id)
      
      if (!trackDataError) {
        setTrack(trackData || []);
      }

      // Filter tracks that are active today
      const todaysTracks = tracks?.filter(track => {
        if (!track.study_days) return false
        return track.study_days.includes(todayName)
      }) || []

      // Group tracks by child
      const learningByChild = children?.map(child => {
        const childTracks = todaysTracks.filter(track => 
          track.name.includes(child.first_name)
        )
        return {
          child,
          tracks: childTracks
        }
      }).filter(item => item.tracks.length > 0)

      setTodaysLearning(learningByChild || [])
    } catch (error) {
      console.error('Error fetching today\'s learning:', error)
    } finally {
      setLoadingLearning(false)
    }
  }

  // Update progress when selected child changes
  const updateProgressForChild = (childId) => {
    if (!childId) {
      // "All Children" view - don't change progress data, let individual cards show their progress
      return
    }
    
    const child = children.find(c => c.id === childId)
    if (child) {
      let newPercent = 0
      if (child.first_name === 'Max') {
        newPercent = 90
      } else if (child.first_name === 'Lilly') {
        newPercent = 48
      }
      
      setProgressData(prev => ({ ...prev, percent: newPercent }))
    }
  }

  const fetchChildren = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      const { data: profile } = await supabase
        .from('profiles')
        .select('family_id')
        .eq('id', user.id)
        .single()

      if (!profile?.family_id) return

      const { data: childrenData } = await supabase
        .from('children')
        .select('*')
        .eq('family_id', profile.family_id)

      if (childrenData) {
        setChildren(childrenData)
        // Initialize selectedChildren with all children selected
        setSelectedChildren(childrenData.map(child => child.id))
      }
    } catch (error) {
      console.error('Error fetching children:', error)
    }
  }

  const fetchFamilyId = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      const { data: profile } = await supabase
        .from('profiles')
        .select('family_id')
        .eq('id', user.id)
        .single()

      if (profile?.family_id) {
        setFamilyId(profile.family_id)
      }
    } catch (error) {
      console.error('Error fetching family ID:', error)
    }
  }

  // Load progress once family known
  useEffect(() => {
    if (familyId) {
      loadProgress()
    }
  }, [familyId])

  // Load tasks when filter changes
  useEffect(() => {
    if (familyId) {
      loadTasks()
    }
  }, [familyId, selectedChildId])

  const loadProgress = async () => {
    try {
      const { data: year, error } = await supabase
        .from('family_years')
        .select('start_date,end_date')
        .eq('family_id', familyId)
        .eq('is_current', true)
        .maybeSingle()
      if (error) throw error

      if (year) {
        const start = new Date(year.start_date)
        const end = new Date(year.end_date)
        const todayDate = new Date()
        const totalMs = Math.max(end - start, 1)
        const doneMs = Math.min(Math.max(todayDate - start, 0), totalMs)
        const percent = Math.round((doneMs / totalMs) * 100)
        
        // Set specific progress percentages for Max and Lilly
        let specificPercent = percent
        if (selectedChildId) {
          const child = children.find(c => c.id === selectedChildId)
          if (child) {
                      if (child.first_name === 'Max') {
            specificPercent = 90
          } else if (child.first_name === 'Lilly') {
            specificPercent = 48
          }
          }
        }
        
        setProgressData({
          yearLabel: `${start.getFullYear()}-${end.getFullYear()}` || 'Current Year',
          start: year.start_date,
          end: year.end_date,
          percent: specificPercent,
        })
      } else {
        // Set default progress for "All Children" view - will show individual child progress in cards
        setProgressData({ yearLabel: '2025-2026', start: '2025-08-01', end: '2026-07-31', percent: 0 })
      }
    } catch (e) {
      console.warn('loadProgress failed:', e)
      setProgressData({ yearLabel: '2025-2026', start: '2025-08-01', end: '2026-07-31', percent: 0 })
    }
  }

  const loadTasks = async () => {
    try {
      // If a child selected, find their subject ids first
      let subjectIds = null
      if (selectedChildId) {
        const { data: subs, error: subErr } = await supabase
          .from('subject')
          .select('id')
          .eq('student_id', selectedChildId)
        if (!subErr && subs) subjectIds = subs.map((s) => s.id)
      }

      let query = supabase
        .from('activities')
        .select('id,name,subject_id,activity_type,schedule_data,created_at')
        .eq('family_id', familyId)
        .order('created_at', { ascending: false })
      if (subjectIds && subjectIds.length > 0) {
        query = query.in('subject_id', subjectIds)
      }
      const { data, error } = await query
      if (error) throw error

      if (data && data.length > 0) {
        const buckets = { todo: [], inProgress: [], done: [] }
        data.forEach((a) => {
          const status =
            (a.schedule_data && (a.schedule_data.status || a.schedule_data.State)) ||
            false ||
            'To do'
          if (/done/i.test(status)) buckets.done.push(a)
          else if (/progress|doing|work/i.test(status)) buckets.inProgress.push(a)
          else buckets.todo.push(a)
        })
        setTasksData(buckets)
      } else {
        // placeholders
        setTasksData({
          todo: [{ id: 'p1', name: 'Math worksheet 3' }],
          inProgress: [{ id: 'p2', name: 'Read chapter 2' }],
          done: [{ id: 'p3', name: 'Journal entry' }],
        })
      }
    } catch (e) {
      console.warn('loadTasks failed:', e)
      setTasksData({
        todo: [{ id: 'p1', name: 'Math worksheet 3' }],
        inProgress: [{ id: 'p2', name: 'Read chapter 2' }],
        done: [{ id: 'p3', name: 'Journal entry' }],
      })
    }
  }

  const handleAddChild = async () => {
    if (!addChildName.trim() || !addChildAge.trim() || !addChildGrade.trim()) {
      Alert.alert('Required Fields', 'Please fill in the name, age, and grade fields.')
      return
    }

    setIsAddingChild(true)
    try {
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) {
        Alert.alert('Error', 'User not authenticated')
        return
      }

      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('family_id')
        .eq('id', user.id)
        .single()

      if (profileError || !profile?.family_id) {
        Alert.alert('Error', 'Family not found')
      return
    }

      const { data: newChild, error: childError } = await supabase
        .from('children')
        .insert([
          {
            first_name: addChildName.trim(),
            age: parseInt(addChildAge),
            grade: parseInt(addChildGrade),
            interests: addChildInterests.trim() || null,
            standards: addChildStandards.trim() || null,
            learning_style: addChildStyle.trim() || null,
            college_bound: addChildCollegeBound,
            avatar: addChildAvatar,
            family_id: profile.family_id
          }
        ])
        .select()
        .single()

      if (childError) {
        console.error('Error adding child:', childError)
        Alert.alert('Error', 'Failed to add child: ' + childError.message)
        return
      }

      // Reset form
      setAddChildName('')
      setAddChildAge('')
      setAddChildGrade('')
      setAddChildInterests('')
      setAddChildStandards('')
      setAddChildStyle('')
      setAddChildCollegeBound(false)
      setAddChildAvatar('prof1')

      Alert.alert('Success', `${addChildName} has been added successfully!`)
      
      // Refresh children list
      fetchChildren()
      if (onChildAdded) {
        onChildAdded()
      }
    } catch (error) {
      console.error('Error adding child:', error)
      Alert.alert('Error', 'An unexpected error occurred')
    } finally {
      setIsAddingChild(false)
    }
  }

  const handleDoodleMessage = async (message) => {
    try {
      setDoodleLoading(true)
      
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('No authenticated user');
      
      const { data: profile } = await supabase
        .from('profiles')
        .select('family_id')
        .eq('id', user.id)
        .single();
      
      if (!profile?.family_id) throw new Error('No family_id found for user');
      const familyId = profile.family_id;

      let conversationId = doodleConversationId;
      if (!conversationId) {
        conversationId = await AIConversationService.createConversation(
          familyId,
          'doodlebot',
          'DoodleBot Assistant'
        );
        setDoodleConversationId(conversationId);
      }

      await AIConversationService.addMessage(conversationId, 'user', message);
      
      setDoodleMessages(prev => [...prev, { role: 'user', content: message, timestamp: Date.now() }])
      
      const currentMessageCount = doodleMessages.length;
      if (currentMessageCount === 0) {
        const welcomeMessage = `Hi! I'm Doodle, your fast chat assistant for Learnadoodle! 

I can help you with:
â€¢ Quick questions â†’ direct answers
â€¢ Log homework/activities â†’ add_activity
â€¢ Check recent progress â†’ progress_summary
â€¢ Request short-term schedule shifts â†’ queue_reschedule
â€¢ Suggest subjects for a child/year
â€¢ Suggest courses (live-class, self-paced, custom)

I can see you have ${children.length} child(ren) set up. How can I help you today?`
        
        await AIConversationService.addMessage(conversationId, 'assistant', welcomeMessage);
        setDoodleMessages(prev => [...prev, { role: 'assistant', content: welcomeMessage, timestamp: Date.now() }])
        setDoodleLoading(false)
        return
      }
      
      // Use the new Doodle assistant
      const response = await processDoodleMessage(message, familyId, conversationId);
      
      // Handle tool execution if needed
      if (response.tool) {
        try {
          const toolResult = await executeTool(response.tool, response.params, familyId);
          if (toolResult.success) {
            response.message += `\n\nâœ… ${response.tool} completed successfully!`;
          }
        } catch (toolError) {
          console.error('Tool execution error:', toolError);
          response.message += `\n\nâŒ Sorry, I couldn't complete that action. Please try again.`;
        }
      }
      
      // Handle fetch requests
      if (response.fetch) {
        if (response.fetch === 'custom-plan') {
          response.message += `\n\nðŸ”„ I'm working on your custom plan. This may take a moment...`;
        } else if (response.fetch === '2-week-plan') {
          response.message += `\n\nðŸ“… I'm generating your 2-week plan. This may take a moment...`;
        }
      }
      
      await AIConversationService.addMessage(conversationId, 'assistant', response.message);
      
      setDoodleMessages(prev => [...prev, { role: 'assistant', content: response.message, timestamp: Date.now() }])
      
    } catch (error) {
      console.error('Error chatting with Doodle:', error)
      const errorMessage = 'Sorry, I encountered an error while processing your request. Please try again.'
      setDoodleMessages(prev => [...prev, { role: 'assistant', content: errorMessage, timestamp: Date.now() }])
    } finally {
      setDoodleLoading(false)
    }
  }

  // If a prompt is passed from the global search bar, send it once
  useEffect(() => {
    if (pendingDoodlePrompt && activeTab === 'search') {
      // Simulate typing into chat and trigger send
      setDoodleInput(pendingDoodlePrompt)
      handleDoodleMessage(pendingDoodlePrompt)
      onConsumeDoodlePrompt && onConsumeDoodlePrompt()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pendingDoodlePrompt, activeTab])

  const handleSendMessage = () => {
    console.log('handleSendMessage called, current input:', doodleInput)
    if (doodleInput.trim()) {
      const messageToSend = doodleInput.trim()
      console.log('Sending message:', messageToSend)
      
      // Clear input immediately
      setDoodleInput('')
      console.log('Input cleared immediately')
      
      // Then handle the message
      handleDoodleMessage(messageToSend)
    }
  }

  // Syllabus upload handlers
  const handleSyllabusProcessed = (syllabusData) => {
    setProcessedSyllabi(prev => [...prev, syllabusData])
    if (onSyllabusProcessed) {
      onSyllabusProcessed(syllabusData)
    }
  }

  const handleOpenSyllabusUpload = () => {
    setShowSyllabusModal(true)
  }

  const handleCloseSyllabusUpload = () => {
    setShowSyllabusModal(false)
  }

  const renderContent = () => {
    // Check if it's a syllabus upload tab for a specific child
    if (activeTab.startsWith('syllabus-upload-')) {
      return renderSyllabusContent()
    }
    
    // Check if it's a to-do list tab for a specific child
    if (activeTab.startsWith('to-do-list-')) {
      return renderToDoListContent()
    }
    
    // Check if it's a projects tab for a specific child
    if (activeTab.startsWith('projects-')) {
      return renderProjectsContent()
    }
    
    // Check if it's a notes page tab for a specific child
    if (activeTab.startsWith('notes-pages-')) {
      return renderNotesContent()
    }
    
    // Check if it's a calendar tab
    if (activeTab === 'calendar') {
      return renderCalendarContent()
    }
    if (activeTab === 'notifications') {
      return (
        <View style={styles.content}>
          <Text style={styles.title}>No notifications right now!</Text>
        </View>
      )
    }
    
    switch (activeTab) {
      case 'search':
        return renderSearchContent()
      case 'home':
        return renderHomeContent()
      case 'add-child':
        return renderAddChildContent()
      case 'add-options':
        return renderAddOptionsContent()
      case 'add-activity':
        return renderAddActivityContent()

      case 'syllabus':
        return renderSyllabusContent()
      case 'calendar-planning':
        return renderCalendarPlanningContent()
      default:
        return renderHomeContent()
    }
  }

  const renderSearchContent = () => {
    return (
      <View style={styles.content}>
        <Text style={styles.title}>Ask Doodle</Text>
        <Text style={styles.subtitle}>Your fast chat assistant for Learnadoodle</Text>
        
        <View style={styles.chatContainer}>
          <View style={styles.messagesContainer}>
            {doodleMessages.length === 0 ? (
              <View style={styles.welcomeMessage}>
                <Text style={styles.welcomeTitle}>Hi! I'm Doodle ðŸ¤–</Text>
                <Text style={styles.welcomeText}>
                  Your fast chat assistant for Learnadoodle. I can help you with:
                </Text>
                <Text style={styles.welcomeBullet}>â€¢ Quick questions â†’ direct answers</Text>
                <Text style={styles.welcomeBullet}>â€¢ Log homework/activities â†’ add_activity</Text>
                <Text style={styles.welcomeBullet}>â€¢ Check recent progress â†’ progress_summary</Text>
                <Text style={styles.welcomeBullet}>â€¢ Request short-term schedule shifts â†’ queue_reschedule</Text>
                <Text style={styles.welcomeBullet}>â€¢ Suggest subjects for a child/year</Text>
                <Text style={styles.welcomeBullet}>â€¢ Suggest courses (live-class, self-paced, custom)</Text>
                <Text style={styles.welcomeText}>
                  I can see you have {children.length} child(ren) set up. How can I help you today?
                </Text>
        </View>
            ) : (
              doodleMessages.map((message, index) => (
                <View key={`doodle-${message.role}-${index}-${message.content.substring(0, 10)}`} style={[
                  styles.message,
                  message.role === 'user' ? styles.userMessage : styles.assistantMessage
                ]}>
                  <Text style={styles.messageText}>{message.content}</Text>
      </View>
              ))
            )}
            {doodleLoading && (
              <View style={styles.loadingMessage}>
                <Text style={styles.loadingText}>Doodle is thinking...</Text>
        </View>
            )}
      </View>
          
          <View style={styles.inputContainer}>
        <TextInput
              style={styles.chatInput}
              placeholder="Ask me anything about your family's learning..."
              value={doodleInput}
              onChangeText={setDoodleInput}
              multiline
              onSubmitEditing={handleSendMessage}
              onKeyPress={(e) => {
                if (e.nativeEvent.key === 'Enter' && !e.nativeEvent.shiftKey) {
                  handleSendMessage();
                }
              }}
            />
          <TouchableOpacity
              style={[styles.sendButton, !doodleInput.trim() && styles.sendButtonDisabled]}
              onPress={handleSendMessage}
              disabled={!doodleInput.trim() || doodleLoading}
          >
              <Text style={styles.sendButtonText}>Send</Text>
          </TouchableOpacity>
        </View>
        </View>
      </View>
    )
  }

  const renderHomeContent = () => {
    return (
      <View style={styles.content}>
        {/* Child Filter Chips */}
        {children.length > 0 && (
          <View style={styles.filterSection}>
            <Text style={styles.filterLabel}>Filter by child:</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.filterScroll}>
              <View style={styles.filterChips}>
            <TouchableOpacity
                  key={'all'} 
                  onPress={() => {
                    setSelectedChildId(null)
                    updateProgressForChild(null)
                  }} 
                  style={[
                    styles.filterChip,
                    selectedChildId === null && styles.filterChipActive
                  ]}
                >
                  <Text style={[
                    styles.filterChipText,
                    selectedChildId === null && styles.filterChipTextActive
                  ]}>
                    All Children
                </Text>
              </TouchableOpacity>
                {children.map((c) => (
              <TouchableOpacity
                    key={c.id} 
            onPress={() => {
                      setSelectedChildId(c.id)
                      updateProgressForChild(c.id)
                    }} 
                    style={[
                      styles.filterChip,
                      selectedChildId === c.id && styles.filterChipActive
                    ]}
                  >
                    <Text style={[
                      styles.filterChipText,
                      selectedChildId === c.id && styles.filterChipTextActive
                    ]}>
                      {c.first_name}
                    </Text>
          </TouchableOpacity>
                ))}
        </View>
            </ScrollView>
      </View>
          )}



        {/* Children Overview Section */}
        {children.length > 0 && (
          <View style={styles.childrenSection}>
            <Text style={styles.sectionTitle}>
              {selectedChildId ? 
                `${children.find(c => c.id === selectedChildId)?.first_name}'s Overview` : 
                'Your Children'
              }
            </Text>
            {!selectedChildId && (
              <Text style={styles.sectionSubtitle}>Click on a child card to view detailed information</Text>
            )}
            <View style={styles.childrenGrid}>
              {(selectedChildId ? 
                children.filter(child => child.id === selectedChildId) : 
                children
                            ).map((child, index) => (
                <TouchableOpacity 
                  key={child.id} 
                  style={styles.childCard}
                  onPress={() => {
                    const studentData = {
                      child: child,
                      tracks: todaysLearning.find(item => item.child.id === child.id)?.tracks || []
                    };
                    handleStudentPress(studentData);
                  }}
                  activeOpacity={0.7}
                >
                  <View style={styles.childHeader}>
                    <Image
                      source={getAvatarSource(child.avatar)}
                      style={styles.childAvatar}
                      resizeMode="contain"
                    />
                    <View style={styles.childInfo}>
                      <Text style={styles.childName}>{child.first_name}</Text>
                      <Text style={styles.childDetails}>
                        Age: {child.age} | Grade: {child.grade}
                      </Text>
                    </View>
                  </View>
                  <View style={styles.childStats}>
                    <View style={styles.statItem}>
                      <Text style={styles.statValue}>{tasksData.todo.length}</Text>
                      <Text style={styles.statLabel}>Tasks</Text>
                    </View>
                    <View style={styles.statItem}>
                      <Text style={styles.statValue}>
                        {child.first_name === 'Max' ? '90' : child.first_name === 'Lilly' ? '48' : '0'}%
                      </Text>
                      <Text style={styles.statLabel}>Progress</Text>
                    </View>
                  </View>
                </TouchableOpacity>
              ))}
            </View>
        </View>
      )}





        {/* Today's Learning Section */}
        {children.length > 0 && (
          <View style={styles.todaysLearningSection}>
            <Text style={styles.sectionTitle}>Today's Learning</Text>
            <Text style={styles.sectionSubtitle}>Click on a student card to view details</Text>
            {loadingLearning ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="small" color="#38B6FF" />
                <Text style={styles.loadingText}>Loading today's schedule...</Text>
        </View>
            ) : todaysLearning.length > 0 ? (
              todaysLearning.map((item, index) => (
                <TouchableOpacity 
                  key={`learning-${item.child.id}-${index}`} 
                  style={styles.childLearningCard}
                  onPress={() => handleStudentPress(item)}
                  activeOpacity={0.7}
                >
                  <View style={styles.childHeader}>
                    <Text style={styles.childName}>{item.child.first_name}</Text>
                    <Text style={styles.childGrade}>Grade {item.child.grade}</Text>
                  </View>
                  {item.tracks.map((track, trackIndex) => (
                    <View key={`track-${track.id || trackIndex}-${item.child.id}`} style={styles.trackItem}>
                      <Text style={styles.trackName}>{track.name}</Text>
                      <Text style={styles.trackSchedule}>{track.class_schedule}</Text>
                      {track.roadmap && (
                        <View style={styles.roadmapPreview}>
                          <Text style={styles.roadmapLabel}>Current Unit:</Text>
                          <Text style={styles.roadmapContent}>
                            {typeof track.roadmap === 'string' 
                              ? track.roadmap 
                              : track.roadmap.units?.[0]?.name || 'Unit in progress'
                            }
                          </Text>
                        </View>
                      )}
                    </View>
                  ))}
                </TouchableOpacity>
              ))
            ) : (
              <View style={styles.noLearningContainer}>
                <Text style={styles.noLearningText}>No learning activities scheduled for today</Text>
                <Text style={styles.noLearningSubtext}>Check the calendar for upcoming lessons</Text>
              </View>
            )}
          </View>
        )}

        {/* Empty State */}
        {children.length === 0 && (
          <View style={styles.emptyState}>
            <Text style={styles.emptyTitle}>Welcome to Learnadoodle!</Text>
            <Text style={styles.emptySubtitle}>
              Get started by adding your first child and setting up your learning environment
            </Text>
        <TouchableOpacity
              style={styles.primaryButton}
              onPress={() => onTabChange('add-child')}
        >
              <Text style={styles.primaryButtonText}>Add Your First Child</Text>
        </TouchableOpacity>
        </View>
      )}

      {/* Student Details Modal */}
      <StudentDetailsModal
        visible={showStudentModal}
        student={selectedStudent}
        onClose={handleCloseStudentModal}
        onDelete={handleDeleteChild}
      />
      

      </View>
    )
  }

  const renderAddChildContent = () => {
    return (
      <ScrollView style={styles.scrollContainer} showsVerticalScrollIndicator={false}>
      <View style={styles.content}>
          <Text style={styles.title}>Family Setup</Text>
          <Text style={styles.subtitle}>Complete your family profile and learning preferences</Text>

          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Add Children</Text>
            <Text style={styles.sectionSubtitle}>Enter each child's information</Text>

            <AddChildForm
              submitting={isAddingChild}
              onSubmit={async (payload) => {
                setIsAddingChild(true)
                try {
                  const { data: { user } } = await supabase.auth.getUser()
                  if (!user) throw new Error('Not authenticated')
                  const { data: profile } = await supabase
                    .from('profiles')
                    .select('family_id')
                    .eq('id', user.id)
                    .single()
                  if (!profile?.family_id) throw new Error('Family not found')

                  const insert = {
                    name: payload.first_name,
                    age: payload.age,
                    grade: payload.grade,
                    interests: payload.interests,
                    standards: payload.standards,
                    learning_style: payload.learning_style,
                    college_bound: payload.college_bound,
                    avatar: payload.avatar,
                    family_id: profile.family_id,
                  }

                  const { data: inserted, error } = await supabase.from('children').insert(insert).select().single()
                  if (error) throw error

                  // refresh
                  await fetchChildren()
                  setShowSubjectSelectForChild(inserted)
                  Alert.alert('Success', `${payload.first_name} has been added! Now pick subjectsâ€¦`)
                } catch (e) {
                  console.error('Add child failed:', e)
                  Alert.alert('Error', e.message || 'Failed to add child')
                } finally {
                  setIsAddingChild(false)
                }
              }}
            />

            {children.length > 0 && (
              <View style={styles.childrenList}>
                <Text style={styles.sectionTitle}>Added Children:</Text>
                {children.map((child, index) => (
                  <View key={`child-${child.id}-${index}`} style={styles.childCard}>
                    <View style={styles.childCardHeader}>
                      <Image source={getAvatarSource(child.avatar)} style={styles.childAvatar} resizeMode="contain" />
                      <View style={styles.childInfo}>
                        <Text style={styles.childName}>{child.first_name}</Text>
                        <Text style={styles.childDetails}>Age: {child.age} | Grade: {child.grade}</Text>
        </View>
      </View>
            </View>
          ))}
        </View>
      )}

            {showSubjectSelectForChild && (
              <Modal visible animationType="slide" onRequestClose={() => setShowSubjectSelectForChild(null)}>
                <View style={{ flex: 1, backgroundColor: '#fff' }}>
                  <SubjectSelectForm
                    child={showSubjectSelectForChild}
                    onClose={() => setShowSubjectSelectForChild(null)}
                    onSaved={() => {
                      setShowSubjectSelectForChild(null)
                      Alert.alert('Subjects saved', 'Great! Let\'s set up your academic year next.');
                      onTabChange && onTabChange('calendar')
                    }}
                  />
      </View>
              </Modal>
        )}
    </View>
        </View>
      </ScrollView>
  )
  }

  const renderSyllabusContent = () => {
    return (
      <View style={styles.content}>
        <Text style={styles.title}>Upload Syllabus</Text>
        <Text style={styles.subtitle}>Convert raw syllabus text into clean Markdown</Text>
        
        <View style={styles.syllabusSection}>
          <Text style={styles.sectionTitle}>Course Syllabus Processing</Text>
          <Text style={styles.sectionSubtitle}>
            Upload your course syllabus to convert it into clean, structured Markdown format using AI.
          </Text>
          
            <TouchableOpacity
            style={styles.button}
            onPress={handleOpenSyllabusUpload}
            >
            <Text style={styles.buttonText}>Upload Syllabus</Text>
            </TouchableOpacity>

          {/* Display processed syllabi */}
          {processedSyllabi.length > 0 && (
            <View style={styles.processedSyllabiSection}>
              <Text style={styles.sectionTitle}>Processed Syllabi</Text>
              {processedSyllabi.map((syllabus, index) => (
                <View key={`syllabus-${syllabus.course_title}-${index}`} style={styles.syllabusCard}>
                  <Text style={styles.syllabusTitle}>{syllabus.course_title}</Text>
                  <Text style={styles.syllabusProvider}>{syllabus.provider_name}</Text>
                  {syllabus.unit_start && (
                    <Text style={styles.syllabusUnit}>Starting from Unit {syllabus.unit_start}</Text>
                  )}
                  <Text style={styles.syllabusPreview} numberOfLines={3}>
                    {syllabus.course_outline}
                </Text>
        </View>
              ))}
            </View>
          )}
        </View>


      </View>
    )
  }

  const renderToDoListContent = () => {
    return (
      <View style={styles.content}>
        <Text style={styles.title}>To-Do List</Text>
        <Text style={styles.subtitle}>Manage tasks and assignments</Text>
        
        <View style={styles.comingSoonSection}>
          <Text style={styles.comingSoonTitle}>To-Do List Coming Soon</Text>
          <Text style={styles.comingSoonText}>
            We're working on a comprehensive to-do list feature that will help you track tasks, assignments, and learning activities for each child.
          </Text>
        </View>
      </View>
    )
  }

  const renderProjectsContent = () => {
    return (
      <View style={styles.content}>
        <Text style={styles.title}>Projects</Text>
        <Text style={styles.subtitle}>Track and manage learning projects</Text>
        
        <View style={styles.comingSoonSection}>
          <Text style={styles.comingSoonTitle}>Projects Page Coming Soon</Text>
          <Text style={styles.comingSoonText}>
            Our projects feature will help you organize and track long-term learning projects, research assignments, and creative activities.
          </Text>
        </View>
      </View>
    )
  }

  const renderNotesContent = () => {
    return (
      <View style={styles.content}>
        <Text style={styles.title}>Notes Pages</Text>
        <Text style={styles.subtitle}>Create and organize learning notes</Text>
        
        <View style={styles.comingSoonSection}>
          <Text style={styles.comingSoonTitle}>Notes Page Coming Soon</Text>
          <Text style={styles.comingSoonText}>
            A powerful notes system is in development that will allow you to create, organize, and share learning notes for each subject and child.
          </Text>
        </View>
      </View>
    )
  }

    // Calendar state
  const [currentMonth, setCurrentMonth] = useState(new Date());
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [calendarEvents, setCalendarEvents] = useState({});
  const [calendarLoading, setCalendarLoading] = useState(false);
  
  // Web-compatible alert function
  const showAlert = (title, message) => {
    if (typeof window !== 'undefined' && window.alert) {
      // Web environment
      window.alert(`${title}\n\n${message}`);
    } else {
      // React Native environment
      Alert.alert(title, message, [{ text: 'OK' }]);
    }
  };





      


  // Fetch real calendar events from Supabase
  const handleEventSelect = (event) => {
    
    setSelectedEvent(event)
    setIsEditingEvent(false)
    setEditedEventData({
      title: event.title,
      childName: event.childName,
      time: event.time,
      type: event.type,
      date: event.date,
      location: event.location || '',
      notes: event.notes || ''
    })
  }

  const handleEditEvent = () => {
    setIsEditingEvent(true)
  }

  const handleSaveEvent = async () => {
    try {
      // Here you would typically save to your database
      // For now, we'll just update the local state
      setSelectedEvent({
        ...selectedEvent,
        ...editedEventData
      })
      setIsEditingEvent(false)
      // You could also update the calendar events here
    } catch (error) {
      console.error('Error saving event:', error)
    }
  }

  const handleCancelEdit = () => {
    setIsEditingEvent(false)
    setEditedEventData({
      title: selectedEvent.title,
      childName: selectedEvent.childName,
      time: selectedEvent.time,
      type: selectedEvent.type,
      date: selectedEvent.date,
      location: selectedEvent.location || '',
      notes: selectedEvent.notes || ''
    })
  }

  const handleCloseEvent = () => {
    setSelectedEvent(null)
    setIsEditingEvent(false)
    setEditedEventData({})
  }

  const handleSearch = async () => {
    if (!searchQuery.trim()) return;
    
    setIsSearching(true);
    try {
      const results = [];
      
      // First, search through what we already have loaded
      Object.entries(calendarEvents).forEach(([dateKey, dayEvents]) => {
        dayEvents.forEach(event => {
          const searchText = `${event.title} ${event.childName} ${event.type}`.toLowerCase();
          if (searchText.includes(searchQuery.toLowerCase())) {
            results.push({
              ...event,
              date: dateKey,
              displayDate: new Date(dateKey).toLocaleDateString()
            });
          }
        });
      });
      
      // If query is very short, show results immediately
      if (searchQuery.length <= 2) {
        setSearchResults(results);
        setIsSearching(false);
        return;
      }
      
      // For comprehensive search, fetch additional months efficiently
      const currentYear = new Date().getFullYear();
      const currentMonth = new Date().getMonth();
      
      // Only fetch 2 months before and after current month
      const monthsToFetch = [];
      for (let i = -2; i <= 2; i++) {
        const month = (currentMonth + i + 12) % 12;
        const year = currentYear + Math.floor((currentMonth + i) / 12);
        if (year >= currentYear - 1 && year <= currentYear + 1) {
          monthsToFetch.push({ month, year });
        }
      }
      
      // Fetch all months in parallel
      const fetchPromises = monthsToFetch.map(({ month, year }) => 
        fetchCalendarEvents(month, year)
      );
      
      const additionalEvents = await Promise.all(fetchPromises);
      
      // Search through additional events and combine with existing results
      additionalEvents.forEach(events => {
        Object.entries(events).forEach(([dateKey, dayEvents]) => {
          dayEvents.forEach(event => {
            const searchText = `${event.title} ${event.childName} ${event.type}`.toLowerCase();
            if (searchText.includes(searchQuery.toLowerCase())) {
              results.push({
                ...event,
                date: dateKey,
                displayDate: new Date(dateKey).toLocaleDateString()
              });
            }
            // Limit results to prevent overwhelming the UI
            if (results.length >= 50) return;
          });
        });
      });
      
      // Show all results at once
      setSearchResults(results);
    } catch (error) {
      console.error('Search error:', error);
      setSearchResults([]);
    } finally {
      setIsSearching(false);
    }
  };

  // Pre-load all calendar data for the entire year
  const preloadCalendarData = async () => {
    if (!familyId || isCalendarDataLoaded) return;
    
    setCalendarDataLoading(true);
    
    try {
      // Get current year and fetch data for the entire year
      const currentYear = new Date().getFullYear();
      const viewingYear = currentMonth.getFullYear();
      const yearToLoad = Math.max(currentYear, viewingYear); // Load current year or viewing year, whichever is later
      const startDate = new Date(yearToLoad, 0, 1); // January 1st
      const endDate = new Date(yearToLoad, 11, 31); // December 31st
      const startDateStr = startDate.toISOString().split('T')[0];
      const endDateStr = endDate.toISOString().split('T')[0];
      
      console.log('Pre-loading calendar data for entire year:', startDateStr, 'to', endDateStr);
      
      const events = {};
      const cache = {};
      
      // Fetch children for this family
      const { data: childrenData, error: childrenError } = await supabase
        .from('children')
        .select('id, first_name')
        .eq('family_id', familyId);
      
      if (childrenError) {
        console.error('Error fetching children:', childrenError);
      }
      
      // Fetch activities for the entire year
      try {
        const { data: activitiesData, error: activitiesError } = await supabase
          .from('activities')
          .select('*');
        
        if (activitiesError) {
          console.error('Error fetching activities:', activitiesError);
        } else if (activitiesData && activitiesData.length > 0) {
          // Filter activities by family_id if available, otherwise show all
          const familyActivities = activitiesData.filter(activity => 
            !activity.family_id || activity.family_id === familyId
          );
          
          familyActivities.forEach(activity => {
            // Handle different date field names gracefully
            let dateKey = null;
            if (activity.schedule_data && activity.schedule_data.scheduled_date) {
              dateKey = activity.schedule_data.scheduled_date;
            } else if (activity.created_at) {
              dateKey = activity.created_at.split('T')[0];
            } else {
              // If no date field, skip this activity
              return;
            }
            
            // Add if it's in the current year
            if (dateKey >= startDateStr && dateKey <= endDateStr) {
              if (!events[dateKey]) events[dateKey] = [];
              
              // Try to assign to a child if we have children data
              const childName = childrenData && childrenData.length > 0 
                ? childrenData[0].first_name 
                : 'Family Activity';
              
              // Ensure title is never undefined or null
              let title = activity.name || 'Activity';
              
              // Clean up malformed titles (remove leading dashes, bullets, etc.)
              if (title && typeof title === 'string') {
                title = title.replace(/^[-â€¢*]\s*/, '').trim();
              }
              
              if (!title || title === 'undefined' || title === 'null' || title === '') {
                console.warn('Found activity with invalid title after cleaning:', activity);
                return; // Skip this activity
              }
              
              events[dateKey].push({
                id: activity.id,
                type: 'activity',
                title: title,
                childName: childName,
                time: 'Scheduled',
                color: 'orange',
                data: activity,
                assignee: activity.assignee || null,
                assignees: activity.assignee ? (() => {
                  try {
                    const parsed = JSON.parse(activity.assignee)
                    return Array.isArray(parsed) ? parsed : [activity.assignee]
                  } catch (e) {
                    return [typeof window !== 'undefined' ? [activity.assignee] : [activity.assignee]]
                  }
                })() : []
              });
            }
          });
        }
      } catch (error) {
        console.error('Error fetching activities:', error);
      }
      
      // Fetch lesson instances (real, date-specific lessons) for the entire year
      try {
        const { data: activityInstances, error: aiError } = await supabase
          .from('activity_instances')
          .select(`
            *,
            activities:activity_id(name, description, assignee, minutes)
          `)
          .eq('family_id', familyId)
          .gte('scheduled_date', startDateStr)
          .lte('scheduled_date', endDateStr);
        
        if (aiError) {
          console.error('Error fetching activity instances:', aiError);
        } else if (activityInstances && activityInstances.length > 0) {
          activityInstances.forEach(instance => {
            const dateKey = (instance.scheduled_date || '').toString();
            if (!dateKey) return;
            if (!events[dateKey]) events[dateKey] = [];

            // Get child name from children table separately if needed
            const childName = 'Student'; // We'll get this from the child_id later if needed
            let title = instance.title || instance.activities?.name || 'Lesson';
            
            // Clean up malformed titles (remove leading dashes, bullets, etc.)
            if (title && typeof title === 'string') {
              title = title.replace(/^[-â€¢*]\s*/, '').trim();
            }
            
            // Ensure title is never undefined, null, or empty after cleaning
            if (!title || title === 'undefined' || title === 'null' || title === '') {
              console.warn('Found activity instance with invalid title after cleaning:', instance);
              return; // Skip this instance
            }
            
            // Format time display - only show start time
            let timeLabel = 'Scheduled';
            if (instance.scheduled_time) {
              timeLabel = String(instance.scheduled_time).slice(0,5);
            }

            // Assignee can come from instance override or activity template
            const assigneeValue = instance.assignee || instance.activities?.assignee || null;
            const assigneesArray = assigneeValue ? (() => {
              try {
                const parsed = JSON.parse(assigneeValue);
                return Array.isArray(parsed) ? parsed : [assigneeValue];
              } catch {
                return [assigneeValue];
              }
            })() : [];

            events[dateKey].push({
              id: instance.id,
              type: 'lesson',
              title: title,
              childName,
              time: timeLabel,
              color: 'blue',
              data: instance,
              status: instance.status || 'todo',
              assignee: assigneeValue,
              assignees: assigneesArray,
              description: instance.description || instance.activities?.description || undefined,
              estimateMinutes: instance.minutes ?? undefined,
              due: instance.due ?? false
            });
          });
        }
      } catch (error) {
        console.error('Error fetching activity instances:', error);
      }
      
      // Fetch holidays for the entire year (only if holidays filter is enabled)
      if (showHolidays) {
        try {
          // Get the current family year ID
          const { data: familyYearData, error: familyYearError } = await supabase
            .from('family_years')
            .select('id')
            .eq('family_id', familyId)
            .eq('is_current', true)
            .maybeSingle();
          
          if (familyYearError) {
            console.error('Error fetching family year:', familyYearError);
          } else if (familyYearData) {
            const { data: holidaysData, error: holidaysError } = await supabase
              .from('holidays')
              .select('*')
              .eq('family_year_id', familyYearData.id);
            
            if (holidaysError) {
              console.error('Error fetching holidays:', holidaysError);
            } else if (holidaysData && holidaysData.length > 0) {
              holidaysData.forEach(holiday => {
                // Use the correct holiday_date field from your database
                let dateKey = null;
                if (holiday.holiday_date) {
                  dateKey = holiday.holiday_date;
                } else if (holiday.start_date) {
                  dateKey = holiday.start_date;
                } else if (holiday.date) {
                  dateKey = holiday.date;
                } else if (holiday.created_at) {
                  dateKey = holiday.created_at.split('T')[0];
                } else {
                  // If no date field, skip this holiday
                  return;
                }
                
                // Add if it's in the current year
                if (dateKey >= startDateStr && dateKey <= endDateStr) {
                  if (!events[dateKey]) events[dateKey] = [];
                  
                  // Ensure title is never undefined or null
                  const title = holiday.holiday_name || 'Holiday';
                  if (!title || title === 'undefined' || title === 'null') {
                    console.warn('Found holiday with invalid title:', holiday);
                    return; // Skip this holiday
                  }
                  
                  events[dateKey].push({
                    id: holiday.id,
                    type: 'holiday',
                    title: title,
                    childName: 'All Family',
                    time: 'All Day',
                    color: 'red',
                    data: holiday
                  });
                }
              });
            }
          }
        } catch (error) {
          console.error('Error fetching holidays:', error);
        }
      }
      
      // Sort events within each day by scheduled_time (if present), else push to bottom
      try {
        const toMinutes = (evt) => {
          const t = evt?.data?.scheduled_time;
          if (!t) return 24 * 60 + (evt.type === 'holiday' ? 1 : 0);
          const parts = String(t).split(':');
          const hours = parseInt(parts[0] || '0', 10);
          const minutes = parseInt(parts[1] || '0', 10);
          return hours * 60 + minutes;
        };
        Object.keys(events).forEach((dateKey) => {
          events[dateKey].sort((a, b) => {
            const ta = toMinutes(a);
            const tb = toMinutes(b);
            if (ta !== tb) return ta - tb;
            const at = (a.title || '').toString().toLowerCase();
            const bt = (b.title || '').toString().toLowerCase();
            if (at && bt) return at.localeCompare(bt);
            if (at) return -1;
            if (bt) return 1;
            return 0;
          });
        });
      } catch (sortErr) {
        console.warn('Event sort skipped due to error:', sortErr);
      }

      // Build comprehensive cache for the entire year
      for (let month = 0; month < 12; month++) {
        const monthStart = new Date(currentYear, month, 1);
        const monthEnd = new Date(currentYear, month + 1, 0);
        const monthKey = `${currentYear}-${month}`;
        
        const monthEvents = {};
        for (let day = monthStart.getDate(); day <= monthEnd.getDate(); day++) {
          const dateKey = new Date(currentYear, month, day).toISOString().split('T')[0];
          if (events[dateKey]) {
            monthEvents[dateKey] = events[dateKey];
          }
        }
        
        cache[monthKey] = monthEvents;
      }

      // Store the comprehensive cache
      setCalendarDataCache(cache);
      setCalendarEvents(events);
      setIsCalendarDataLoaded(true);
      
      console.log('Calendar data pre-loaded successfully. Events for', Object.keys(events).length, 'days');
      
    } catch (error) {
      console.error('Error pre-loading calendar data:', error);
    } finally {
      setCalendarDataLoading(false);
    }
  };

  // Load data for a specific year if not already cached
  const loadYearData = async (year) => {
    if (!familyId) return;
    
    const yearKey = `${year}`;
    if (calendarDataCache[yearKey]) return; // Already loaded
    
    console.log('Loading data for year:', year);
    
    try {
      const startDate = new Date(year, 0, 1);
      const endDate = new Date(year, 11, 31);
      const startDateStr = startDate.toISOString().split('T')[0];
      const endDateStr = endDate.toISOString().split('T')[0];
      
      // Fetch activities for the year
      const { data: activitiesData, error: activitiesError } = await supabase
        .from('activities')
        .select('*')
        .gte('created_at', startDateStr)
        .lte('created_at', endDateStr);
      
      if (activitiesError) {
        console.error('Error fetching activities for year:', year, activitiesError);
        return;
      }
      
      // Process activities and add to cache
      const yearEvents = {};
      if (activitiesData) {
        activitiesData.forEach(activity => {
          let dateKey = null;
          if (activity.schedule_data && activity.schedule_data.scheduled_date) {
            dateKey = activity.schedule_data.scheduled_date;
          } else if (activity.created_at) {
            dateKey = activity.created_at.split('T')[0];
          }
          
          if (dateKey && dateKey >= startDateStr && dateKey <= endDateStr) {
            if (!yearEvents[dateKey]) yearEvents[dateKey] = [];
            
            const title = activity.name || 'Activity';
            yearEvents[dateKey].push({
              id: activity.id,
              type: 'activity',
              title: title,
              data: activity
            });
          }
        });
      }
      
      // Add to cache
      setCalendarDataCache(prev => ({
        ...prev,
        [yearKey]: yearEvents
      }));
      
    } catch (error) {
      console.error('Error loading year data:', error);
    }
  };

  // Legacy function for backward compatibility (now just returns cached data)
  const fetchCalendarEvents = async (month, year) => {
    if (!familyId) return {};
    
    // If we have cached data, return it immediately
    if (isCalendarDataLoaded && calendarDataCache[`${year}-${month}`]) {
      return calendarDataCache[`${year}-${month}`];
    }
    
    // If no cached data, trigger pre-loading
    if (!isCalendarDataLoaded) {
      await preloadCalendarData();
      return calendarDataCache[`${year}-${month}`] || {};
    }
    
    return {};
  };
  
  // Pre-load all calendar data when familyId is available
  useEffect(() => {
    if (familyId && !isCalendarDataLoaded && !calendarDataLoading) {
      console.log('Triggering calendar data pre-load for family:', familyId);
      preloadCalendarData();
    }
  }, [familyId, isCalendarDataLoaded, calendarDataLoading]);

  // Update calendar events when month changes, but only if calendar tab is active
  useEffect(() => {
    if (familyId && activeTab === 'calendar' && isCalendarDataLoaded) {
      const monthKey = `${currentMonth.getFullYear()}-${currentMonth.getMonth()}`;
      const monthEvents = calendarDataCache[monthKey] || {};
      setCalendarEvents(monthEvents);
      
      // Check if we need to load data for the current year
      const currentYear = currentMonth.getFullYear();
      const yearKey = `${currentYear}`;
      if (!calendarDataCache[yearKey]) {
        loadYearData(currentYear);
      }
    }
  }, [currentMonth, familyId, activeTab, isCalendarDataLoaded, calendarDataCache]);

  // Update calendar events when filters change (filter from cached data)
  useEffect(() => {
    if (familyId && activeTab === 'calendar' && isCalendarDataLoaded) {
      setCalendarLoading(true);
      
      // Filter cached data based on current filters
      const monthKey = `${currentMonth.getFullYear()}-${currentMonth.getMonth()}`;
      let monthEvents = calendarDataCache[monthKey] || {};
      
      // Apply child filter if needed
      if (selectedChildren.length > 0) {
        const selectedChildNames = children
          .filter(c => selectedChildren.includes(c.id))
          .map(c => c.first_name);
        
        const filteredEvents = {};
        Object.keys(monthEvents).forEach(dateKey => {
          const dayEvents = monthEvents[dateKey].filter(event => {
            // Filter by child name or assignees
            if (event.type === 'holiday') {
              return true; // Always show holidays
            }
            
            // Check if any selected child is assigned to this event
            if (event.assignees && event.assignees.length > 0) {
              if (selectedChildNames.some(childName => event.assignees.includes(childName))) {
                return true;
              }
            }
            
            // Check if any selected child is in the child_name JSON array
            if (event.data?.child_name) {
              try {
                const childNameArray = JSON.parse(event.data.child_name);
                if (Array.isArray(childNameArray) && selectedChildNames.some(childName => childNameArray.includes(childName))) {
                  return true;
                }
              } catch (e) {
                // If parsing fails, try as single string
                if (selectedChildNames.some(childName => event.data.child_name === childName)) {
                  return true;
                }
              }
            }
            
            // Check if the event's childName matches any selected child
            if (event.childName) {
              if (selectedChildNames.includes(event.childName)) {
                return true;
              }
            }
            
            return false; // Don't show events that don't match any selected child
          });
          if (dayEvents.length > 0) {
            filteredEvents[dateKey] = dayEvents;
          }
        });
        monthEvents = filteredEvents;
      }
      
      // Apply holidays filter
      if (!showHolidays) {
        const filteredEvents = {};
        Object.keys(monthEvents).forEach(dateKey => {
          const dayEvents = monthEvents[dateKey].filter(event => event.type !== 'holiday');
          if (dayEvents.length > 0) {
            filteredEvents[dateKey] = dayEvents;
          }
        });
        monthEvents = filteredEvents;
      }
      
      setCalendarEvents(monthEvents);
      setCalendarLoading(false);
    }
      }, [selectedChildren, showHolidays, currentMonth, familyId, activeTab, isCalendarDataLoaded, calendarDataCache]);

  // Fetch calendar data when switching to calendar tab
  useEffect(() => {
    if (activeTab === 'calendar' && familyId && !isCalendarDataLoaded) {
      console.log('Calendar tab activated, triggering data pre-load');
      preloadCalendarData();
    }
  }, [activeTab, familyId, isCalendarDataLoaded]);

  // Trigger search when query changes
  useEffect(() => {
    if (searchQuery.trim()) {
      const timeoutId = setTimeout(() => {
        handleSearch();
      }, 500); // Increased debounce to 500ms for better performance
      
      return () => clearTimeout(timeoutId);
    } else {
      setSearchResults([]);
    }
  }, [searchQuery]);

  const renderCalendarContent = () => {
    if (!familyId) {
      return (
        <View style={styles.content}>
          <Text style={styles.title}>Calendar</Text>
          <Text style={styles.subtitle}>Loading family information...</Text>
        </View>
      )
    }

    // Show loading state for initial calendar load
    if (!isCalendarDataLoaded || calendarDataLoading) {
      return (
        <View style={styles.content}>
          <Text style={styles.title}>Calendar</Text>
          <Text style={styles.subtitle}>Pre-loading calendar data...</Text>
          <View style={{ 
            marginTop: 20,
            alignItems: 'center' 
          }}>
            <Animated.View style={[styles.loadingSpinner, { transform: [{ rotate: spin }] }]} />
            <Text style={{
              marginTop: 16,
              fontSize: 14,
              color: '#6b7280',
              textAlign: 'center'
            }}>
              Loading entire year of calendar events...
            </Text>
            <Text style={{
              marginTop: 8,
              fontSize: 12,
              color: '#9ca3af',
              textAlign: 'center'
            }}>
              This will make navigation instant!
            </Text>
          </View>
        </View>
      )
    }

    const goToPreviousMonth = () => {
      setCurrentMonth(prev => {
        const newDate = new Date(prev);
        newDate.setMonth(prev.getMonth() - 1);
        return newDate;
      });
    };

    const goToNextMonth = () => {
      setCurrentMonth(prev => {
        const newDate = new Date(prev);
        newDate.setMonth(prev.getMonth() + 1);
        return newDate;
      });
    };

    const goToToday = () => {
      setCurrentMonth(new Date());
    };

  const refreshCalendarData = async () => {
    if (familyId) {
      setIsCalendarDataLoaded(false);
      setCalendarDataCache({});
      await preloadCalendarData();
    }
    };

    const formatMonthYear = (date) => {
      return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
    };
        
        return (
          <View style={{ flex: 1, backgroundColor: '#ffffff', flexDirection: 'row', height: '100vh', overflow: 'hidden' }}>
                        {/* Left Sidebar - Collapsible Calendar Sidebar */}
            <View style={{
              width: sidebarCollapsed ? 72 : 220,
              backgroundColor: '#ffffff',
              borderRightWidth: 1,
              borderRightColor: '#e5e7eb',
              transition: 'width 0.3s ease',
              height: '100vh',
              overflow: 'hidden'
            }}>


                 {!sidebarCollapsed ? (
                   <View style={{
                  padding: 8, 
                  flex: 1, 
                  flexDirection: 'column',
                  justifyContent: 'space-between'
                }}>
                  {/* Content Area - Takes up available space */}
                  <View style={{ flex: 1 }}>
                    {/* Filters Section */}
                     <View style={{
                      padding: 8,
                      backgroundColor: '#ffffff',
                      borderRadius: 12,
                      borderWidth: 1,
                      borderColor: '#e5e7eb'
                    }}>


                      <Text style={{
                        fontSize: 11,
                        color: '#6b7280',
                        marginTop: 2,
                        marginBottom: 2
                      }}>
                        Children
                      </Text>
                      {children.map((child) => (
          <TouchableOpacity
                          key={child.id} 
                         style={{
                            flexDirection: 'row',
                           alignItems: 'center',
                            paddingVertical: 4,
                            gap: 8
                          }}
                          onPress={() => {
                            setSelectedChildren(prev => {
                              if (prev.includes(child.id)) {
                                return prev.filter(id => id !== child.id);
                              } else {
                                return [...prev, child.id];
                              }
                            });
                          }}
                        >
                          <View style={{
                            width: 16,
                            height: 16,
                            borderWidth: 2,
                            borderColor: selectedChildren.includes(child.id) ? '#3b82f6' : '#d1d5db',
                            backgroundColor: selectedChildren.includes(child.id) ? '#3b82f6' : 'transparent',
                            borderRadius: 3,
                           alignItems: 'center',
                           justifyContent: 'center'
                          }}>
                            {selectedChildren.includes(child.id) && (
                              <Text style={{
                                color: '#ffffff',
                                fontSize: 10,
                                fontWeight: 'bold'
                              }}>
                                âœ“
                              </Text>
                            )}
                          </View>
                          <Text style={{ color: '#1f2937' }}>{child.first_name}</Text>
        </TouchableOpacity>
                      ))}

                                              <Text style={{
                          fontSize: 11,
                          color: '#6b7280',
                          marginTop: 8,
                          marginBottom: 2
                        }}>
                          Show Holidays
                        </Text>
            <TouchableOpacity
                         style={{
                          flexDirection: 'row',
                           alignItems: 'center',
                          paddingVertical: 4,
                          gap: 8
                        }}
                        onPress={() => setShowHolidays(!showHolidays)}
                      >
                   <View style={{
                          width: 16,
                          height: 16,
                          borderWidth: 2,
                          borderColor: showHolidays ? '#3b82f6' : '#d1d5db',
                          backgroundColor: showHolidays ? '#3b82f6' : 'transparent',
                          borderRadius: 3,
                     alignItems: 'center',
                         justifyContent: 'center'
                        }}>
                          {showHolidays && (
                            <Text style={{
                              color: '#ffffff',
                              fontSize: 10,
                              fontWeight: 'bold'
                            }}>
                              âœ“
                            </Text>
                          )}
                        </View>
                                                <Text style={{ color: '#1f2937' }}>US Holidays</Text>
                      </TouchableOpacity>

                      <Text style={{
                        fontSize: 11,
                        color: '#6b7280',
                        marginTop: 8,
                        marginBottom: 2
                      }}>
                        Show AI Suggestions
                      </Text>
              <TouchableOpacity
                       style={{
                          flexDirection: 'row',
                         alignItems: 'center',
                          paddingVertical: 4,
                          gap: 8
                        }}
                        onPress={() => setShowComingSoonModal(true)}
                      >
                        <View style={{
                          width: 16,
                          height: 16,
                          borderWidth: 2,
                          borderColor: showAISuggestions ? '#3b82f6' : '#d1d5db',
                          backgroundColor: showAISuggestions ? '#3b82f6' : 'transparent',
                          borderRadius: 3,
                          alignItems: 'center',
                          justifyContent: 'center'
                        }}>
                          {showAISuggestions && (
                            <Text style={{
                              color: '#ffffff',
                              fontSize: 10,
                              fontWeight: 'bold'
                            }}>
                              âœ“
                            </Text>
                          )}
                        </View>
                        <Text style={{ color: '#1f2937' }}>Doodle Suggestions</Text>
              </TouchableOpacity>
          </View>
               </View>

                  {/* MiniMonth Calendar - Bottom */}
                  <View style={{
                    padding: 8,
                    backgroundColor: '#ffffff',
                    borderRadius: 12,
                    borderWidth: 1,
                    borderColor: '#e5e7eb',
                    marginTop: 12
                  }}>
                    {/* Header */}
                    <View style={{
                      flexDirection: 'row',
                      alignItems: 'center',
                      justifyContent: 'space-between',
                      marginBottom: 8
                    }}>
                      <Text style={{
                        fontSize: 14,
                        fontWeight: '600',
                        color: '#111827'
                      }}>
                        {miniCalendarMonth.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}
                      </Text>
                      <View style={{
                        flexDirection: 'row',
                        alignItems: 'center',
                        gap: 4
                    }}>
              <TouchableOpacity
                        onPress={() => {
                            const newMonth = new Date(miniCalendarMonth);
                            newMonth.setMonth(miniCalendarMonth.getMonth() - 1);
                            setMiniCalendarMonth(newMonth);
                        }}
                        style={{
                          paddingHorizontal: 8,
                          paddingVertical: 4,
                          borderRadius: 8
                        }}
                      >
                        <Text style={{ fontSize: 20, color: '#374151' }}>â€¹</Text>
              </TouchableOpacity>
          <TouchableOpacity
            onPress={() => {
                            const newMonth = new Date(miniCalendarMonth);
                            newMonth.setMonth(miniCalendarMonth.getMonth() + 1);
                            setMiniCalendarMonth(newMonth);
                        }}
                        style={{
                          paddingHorizontal: 8,
                          paddingVertical: 4,
                          borderRadius: 8
                        }}
                      >
                        <Text style={{ fontSize: 20, color: '#374151' }}>â€º</Text>
                  </TouchableOpacity>
                      </View>
                </View>

                    {/* Week labels */}
                    <View style={{
                      flexDirection: 'row',
                      justifyContent: 'center',
                      marginBottom: 4,
                      gap: 2
                    }}>
                      {['S','M','T','W','T','F','S'].map((d, index) => (
                        <Text key={`day-header-${d}-${index}`} style={{
                          width: 24,
                          textAlign: 'center',
                          fontSize: 10,
                          color: '#6b7280'
                        }}>
                          {d}
                        </Text>
              ))}
            </View>

                    {/* Mini Calendar Grid */}
                    <View style={{ gap: 2 }}>
                      {!isCalendarDataLoaded || calendarDataLoading ? (
                        <View style={{ 
                          height: 100,
                          justifyContent: 'center', 
                          alignItems: 'center'
                        }}>
                          <Animated.View style={{ 
                            width: 20,
                            height: 20,
                            borderRadius: 10,
                            borderWidth: 2,
                            borderColor: '#e5e7eb',
                            borderTopColor: '#3b82f6',
                            transform: [{ rotate: spin }]
                          }} />
                          <Text style={{
                            marginTop: 8,
                            fontSize: 10,
                            color: '#9ca3af',
                            textAlign: 'center'
                          }}>
                            Loading...
                          </Text>
                        </View>
                      ) : (
                        (() => {
                        const year = miniCalendarMonth.getFullYear();
                        const month = miniCalendarMonth.getMonth();
                        const firstDayOfMonth = new Date(year, month, 1);
                        const startDate = new Date(firstDayOfMonth);
                        startDate.setDate(startDate.getDate() - firstDayOfMonth.getDay());
                        
                        const weeks = [];
                        let currentDate = new Date(startDate);
                        
                        for (let week = 0; week < 6; week++) {
                          const weekDays = [];
                          for (let day = 0; day < 7; day++) {
                            weekDays.push(new Date(currentDate));
                            currentDate.setDate(currentDate.getDate() + 1);
                          }
                          weeks.push(weekDays);
                        }
                        
                        return weeks.map((week, weekIndex) => (
                          <View key={`mini-week-${weekIndex}`} style={{
                            flexDirection: 'row',
                              justifyContent: 'center',
                              gap: 2
                          }}>
                            {week.map((date, dayIndex) => {
                              const inMonth = date.getMonth() === month;
                              const isToday = date.toDateString() === new Date().toDateString();
                              const dayNumber = date.getDate();
                              
                              return (
            <TouchableOpacity
                                  key={`mini-day-${weekIndex}-${dayIndex}-${date.toISOString().split('T')[0]}`}
                                  onPress={() => {
                                    // Navigate main calendar to this month if day is clicked
                                    if (inMonth) {
                                      setCurrentMonth(new Date(year, month, 1));
                                    }
                                  }}
              style={{
                                      width: 24,
                                      height: 24,
                                      paddingHorizontal: 4,
                                      paddingVertical: 2,
                                      borderRadius: 4,
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    backgroundColor: '#ffffff',
                                    borderWidth: isToday ? 1 : 0,
                                    borderColor: isToday ? '#d1d5db' : 'transparent',
                                    cursor: 'pointer'
                                  }}
                                >
                                  <Text style={{
                                      fontSize: 12,
                                    color: inMonth ? '#111827' : '#9ca3af'
                                  }}>
                                    {dayNumber}
                                  </Text>
                                  
                                  {/* Mini Calendar - No Chips */}
                                  {/* Chips removed for cleaner mini calendar view */}
                                </TouchableOpacity>
                              );
                            })}
        </View>
                        ));
                        })()
                      )}
                    </View>
                  </View>


                </View>
              ) : (
                /* Collapsed Sidebar Content */
                <View style={{
                  alignItems: 'center',
                  justifyContent: 'center',
                  height: '100%'
                }}>
                  {/* Show Sidebar Button */}
                  <TouchableOpacity
                    onPress={() => setSidebarCollapsed(false)}
                    style={{
                      width: 32,
                      height: 32,
                      alignItems: 'center',
                      justifyContent: 'center'
                    }}
                  >
                    <Ionicons 
                      name="chevron-forward-outline" 
                      size={20} 
                      color="#9ca3af" 
                    />
                  </TouchableOpacity>
                </View>
              )}
            </View>
            
                         {/* Center Column - Calendar */}
             <View style={{ flex: 1, padding: 16, height: '100vh', overflow: 'hidden' }}>



               {/* Calendar Header */}
               <View style={{ 
                 flexDirection: 'row', 
                 alignItems: 'center', 
                 justifyContent: 'space-between',
                 marginBottom: 24
               }}>
                 {/* Month/Year Title - Left Aligned */}
                 <Text style={{ fontSize: 24, fontWeight: '600', color: '#111827' }}>
                   {formatMonthYear(currentMonth)}
                 </Text>
                 
                 {/* Navigation Buttons - Right Aligned */}
                 <View style={{ 
                   flexDirection: 'row', 
                   alignItems: 'center',
                   gap: 8
                 }}>
            <TouchableOpacity
              onPress={goToPreviousMonth}
              style={{
                       borderRadius: 6, 
                       borderWidth: 1,
                       borderColor: '#e1e5e9', 
                       paddingHorizontal: 6, 
                       paddingVertical: 2,
                       minHeight: 24,
                       alignItems: 'center',
                       justifyContent: 'center'
                     }}
                   >
                     <Text style={{ color: '#374151', fontSize: 16 }}>â€¹</Text>
                   </TouchableOpacity>
                   
                   <TouchableOpacity
                     onPress={() => {
                       const today = new Date();
                       const currentMonthYear = currentMonth.getFullYear() * 12 + currentMonth.getMonth();
                       const todayMonthYear = today.getFullYear() * 12 + today.getMonth();
                       
                       if (currentMonthYear !== todayMonthYear) {
                         setCurrentMonth(today);
                       }
                     }}
                     style={{
                       borderRadius: 6, 
                borderWidth: 1,
                  borderColor: '#e1e5e9', 
                  paddingHorizontal: 8, 
                       paddingVertical: 2,
                       minHeight: 24,
                       alignItems: 'center',
                       justifyContent: 'center'
                     }}
                   >
                     <Text style={{ color: '#374151', fontSize: 12, fontWeight: '500' }}>Today</Text>
            </TouchableOpacity>
                
            <TouchableOpacity
              onPress={goToNextMonth}
              style={{
                       borderRadius: 6, 
                borderWidth: 1,
                  borderColor: '#e1e5e9', 
                       paddingHorizontal: 6, 
                       paddingVertical: 2,
                       minHeight: 24,
                       alignItems: 'center',
                       justifyContent: 'center'
                     }}
                   >
                     <Text style={{ color: '#374151', fontSize: 16 }}>â€º</Text>
            </TouchableOpacity>
                
            <TouchableOpacity
                     onPress={openNewEventForm}
              style={{
                       borderRadius: 6, 
                       borderWidth: 1,
                       borderColor: '#e1e5e9', 
                       paddingHorizontal: 6, 
                       paddingVertical: 2,
                       minHeight: 24,
                       alignItems: 'center',
                       justifyContent: 'center'
                     }}
                   >
                     <Text style={{ color: '#374151', fontSize: 16 }}>+</Text>
            </TouchableOpacity>
                   
                   {calendarLoading && (
                     <Animated.View style={{ 
                       marginLeft: 8,
                       width: 12,
                       height: 12,
                       borderRadius: 6,
                       borderWidth: 1.5,
                       borderColor: '#e5e7eb',
                       borderTopColor: '#3b82f6',
                       transform: [{ rotate: spin }]
                     }} />
                   )}
                 </View>
            </View>
            
            {/* Calendar Grid */}
            <View style={{ 
              backgroundColor: '#ffffff', 
              borderWidth: 1, 
              borderColor: '#e1e5e9', 
              borderRadius: 12,
              flex: 1,
              overflow: 'hidden'
            }}>
              {/* Day Headers */}
              <View style={{ 
                flexDirection: 'row', 
                backgroundColor: '#f9fafb',
                borderBottomWidth: 1,
                borderBottomColor: '#e1e5e9'
              }}>
                {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, index) => (
                  <View key={`calendar-header-${day}-${index}`} style={{ 
                    flex: 1, 
                    borderRightWidth: index < 6 ? 1 : 0,
                    borderRightColor: '#e1e5e9',
                    paddingVertical: 12,
                    paddingHorizontal: 8
                  }}>
                    <Text style={{ 
                      fontSize: 12, 
                      color: '#6b7280', 
                      textAlign: 'center',
                      fontWeight: '600'
                    }}>{day.toUpperCase()}</Text>
            </View>
          ))}
      </View>
              
              {/* Calendar Days Grid */}
              <View style={{ backgroundColor: '#ffffff', flex: 1 }}>
                {calendarLoading ? (
                  // Loading state for calendar grid (filtering)
                  <View style={{ 
                    flex: 1, 
                    justifyContent: 'center', 
                    alignItems: 'center',
                    padding: 40
                  }}>
                    <Animated.View style={[styles.loadingSpinner, { transform: [{ rotate: spin }] }]} />
                    <Text style={{
                      marginTop: 16,
                      fontSize: 14,
                      color: '#6b7280',
                      textAlign: 'center'
                    }}>
                      Applying filters...
                    </Text>
                    <Text style={{
                      marginTop: 8,
                      fontSize: 12,
                      color: '#9ca3af',
                      textAlign: 'center'
                    }}>
                      Filtering from cached data
                    </Text>
                  </View>
                ) : (
                  (() => {
                    // Show loading state if no events have been loaded yet
                    if (Object.keys(calendarEvents).length === 0 && !isCalendarDataLoaded) {
                      return (
                        <View style={{ 
                          flex: 1, 
                          justifyContent: 'center', 
                          alignItems: 'center',
                          padding: 40
                        }}>
                          <Animated.View style={[styles.loadingSpinner, { transform: [{ rotate: spin }] }]} />
                          <Text style={{
                            marginTop: 16,
                            fontSize: 14,
                            color: '#6b7280',
                            textAlign: 'center'
                          }}>
                            Loading calendar events...
                          </Text>
                        </View>
                      );
                    }

                  // Calculate proper month boundaries for currentMonth
                  const year = currentMonth.getFullYear();
                  const month = currentMonth.getMonth();
                  const firstDayOfMonth = new Date(year, month, 1);
                  const lastDayOfMonth = new Date(year, month + 1, 0);
                  const startDate = new Date(firstDayOfMonth);
                  startDate.setDate(startDate.getDate() - firstDayOfMonth.getDay()); // Start from Sunday
                  
                  const weeks = [];
                  let currentDate = new Date(startDate);
                  
                  // Generate 6 weeks
                  for (let week = 0; week < 6; week++) {
                    const weekDays = [];
                    for (let day = 0; day < 7; day++) {
                      weekDays.push(new Date(currentDate));
                      currentDate.setDate(currentDate.getDate() + 1);
                    }
                    weeks.push(weekDays);
                  }
                  
                  return weeks.map((week, weekIndex) => (
                    <View key={`calendar-week-${weekIndex}`} style={{ 
                      flexDirection: 'row',
                      flex: 1,
                      borderBottomWidth: weekIndex < 5 ? 1 : 0,
                      borderBottomColor: '#e1e5e9'
                    }}>
                      {week.map((date, dayIndex) => {
                        const isCurrentMonth = date.getMonth() === month;
                        const isToday = date.toDateString() === new Date().toDateString();
                        const dayNumber = date.getDate();
                        
                        return (
                          <TouchableOpacity
                            key={`calendar-day-${weekIndex}-${dayIndex}-${date.toISOString().split('T')[0]}`}
                            onPress={() => {
                              const dateKey = date.toISOString().split('T')[0];
                              const dayEvents = calendarEvents[dateKey] || [];
                              if (dayEvents.length > 0) {
                                showAlert(
                                  `Events for ${date.toLocaleDateString()}`,
                                  dayEvents.map(event => `${event.title || 'Untitled'} (${event.type})`).join('\n')
                                );
                              }
                            }}
                            style={{ 
                              flex: 1, 
                              borderRightWidth: dayIndex < 6 ? 1 : 0,
                              borderRightColor: '#e1e5e9',
                              padding: 8,
                              backgroundColor: isToday ? 'rgba(59, 130, 246, 0.1)' : 'transparent',
                              cursor: 'pointer'
                            }}
                            // Web-specific click handler
                            {...(typeof window !== 'undefined' && {
                              onClick: () => {
                                const dateKey = date.toISOString().split('T')[0];
                                const dayEvents = calendarEvents[dateKey] || [];
                                if (dayEvents.length > 0) {
                                  // For now, just show the first event
                                  if (dayEvents.length > 0) {
                                    handleEventSelect(dayEvents[0]);
                                  }
                                }
                              }
                            })}
                          >
                            <Text style={{ 
                              fontSize: 14, 
                              color: isCurrentMonth ? '#374151' : '#d1d5db',
                              fontWeight: isToday ? '600' : 'normal',
                              marginBottom: 4
                            }}>
                              {dayNumber}
                            </Text>
                            
                            {/* Calendar Chips */}
                            <View style={styles.calendarChips}>
                              {/* Dynamic Event Chips from generated data */}
                              {(() => {
                                const dateKey = date.toISOString().split('T')[0];
                                const dayEvents = calendarEvents[dateKey] || [];
                                
                                // Filter valid events and limit to 4 for display (increased from 3)
                                const validEvents = dayEvents
                                  .filter(event => event.title && event.title !== 'undefined' && event.title !== 'null')
                                  .slice(0, 4);
                                const remainingCount = dayEvents.length - validEvents.length;
                                
                                return (
                                  <>
                                    {/* Show up to 3 compact event chips */}
                                    {validEvents.map((event, eventIndex) => (
                                      <TouchableOpacity
                                        key={`event-${eventIndex}`}
                                        onPress={() => {
                                          handleEventSelect(event);
                                        }}
                                        style={[
                                          styles.eventChip,
                                          event.type === 'lesson' && styles.chipLesson,
                                          event.type === 'activity' && styles.chipActivity,
                                          event.type === 'holiday' && styles.chipHoliday
                                        ]}
                                        // Web-specific click handler
                                        {...(typeof window !== 'undefined' && {
                                          onClick: () => {
                                            if (event.type === 'lesson') {
                                              showAlert(
                                                `${event.title}`,
                                                `${event.childName} - ${event.time}\n\nSubject: ${event.subjectName || 'Unknown'}\nTrack ID: ${event.trackId}\n\n${event.type.charAt(0).toUpperCase() + event.type.slice(1)} scheduled for ${date.toLocaleDateString()}`
                                              );
                                            } else {
                                              showAlert(
                                                `${event.title}`,
                                                `${event.childName} - ${event.time}\n\n${event.type.charAt(0).toUpperCase() + event.type.slice(1)} scheduled for ${date.toLocaleDateString()}`
                                              );
                                            }
                                          }
                                        })}
                                      >
                                        <Text style={styles.chipText} numberOfLines={1}>
                                            {event.time ? (() => {
                                              // Check if this is a time range (contains "-")
                                              if (event.time.includes(' - ')) {
                                                const [startTime, endTime] = event.time.split(' - ')
                                                
                                                // Format start time
                                                const startMatch = startTime.match(/(\d{1,2}):(\d{2})/)
                                                let startDisplay = startTime
                                                if (startMatch) {
                                                  let hours = parseInt(startMatch[1])
                                                  const minutes = startMatch[2]
                                                  
                                                  const period = hours >= 12 ? 'PM' : 'AM'
                                                  if (hours > 12) {
                                                    hours -= 12
                                                  } else if (hours === 0) {
                                                    hours = 12
                                                  }
                                                  
                                                  startDisplay = minutes === '00' ? `${hours} ${period}` : `${hours}:${minutes} ${period}`
                                                }
                                                
                                                // Format end time
                                                const endMatch = endTime.match(/(\d{1,2}):(\d{2})/)
                                                let endDisplay = endTime
                                                if (endMatch) {
                                                  let hours = parseInt(endMatch[1])
                                                  const minutes = endMatch[2]
                                                  
                                                  const period = hours >= 12 ? 'PM' : 'AM'
                                                  if (hours > 12) {
                                                    hours -= 12
                                                  } else if (hours === 0) {
                                                    hours = 12
                                                  }
                                                  
                                                  endDisplay = minutes === '00' ? `${hours} ${period}` : `${hours}:${minutes} ${period}`
                                                }
                                                
                                                return (
                                                  <Text>
                                                    <Text style={{ fontWeight: '400' }}>{startDisplay}-{endDisplay} </Text>
                                                    <Text style={{ fontWeight: '600' }}>{event.title}</Text>
                                        </Text>
                                                )
                                              } else {
                                                // Single time (original logic)
                                                const timeMatch = event.time.match(/(\d{1,2}):(\d{2})/)
                                                if (timeMatch) {
                                                  let hours = parseInt(timeMatch[1])
                                                  const minutes = timeMatch[2]
                                                  
                                                  const period = hours >= 12 ? 'PM' : 'AM'
                                                  if (hours > 12) {
                                                    hours -= 12
                                                  } else if (hours === 0) {
                                                    hours = 12
                                                  }
                                                  
                                                  // Show just hour if minutes are 00, otherwise show full time
                                                  const timeDisplay = minutes === '00' ? `${hours} ${period}` : `${hours}:${minutes} ${period}`
                                                  return (
                                                    <Text>
                                                      <Text style={{ fontWeight: '400' }}>{timeDisplay} </Text>
                                                      <Text style={{ fontWeight: '600' }}>{event.title}</Text>
                                                    </Text>
                                                  )
                                                }
                                                return <Text style={{ fontWeight: '600' }}>{event.title}</Text>
                                              }
                                            })() : <Text style={{ fontWeight: '600' }}>{event.title}</Text>}
                                        </Text>
                                      </TouchableOpacity>
                                    ))}
                                    
                                    {/* Show remaining count if there are more events */}
                                    {remainingCount > 0 && (
                                      <View style={{
                                        backgroundColor: 'rgba(156, 163, 175, 0.2)',
                                        borderRadius: 8,
                                        paddingHorizontal: 6,
                                        paddingVertical: 4,
                                        minWidth: 24,
                                        alignItems: 'center',
                                        borderWidth: 1,
                                        borderColor: 'rgba(156, 163, 175, 0.3)',
                                        cursor: 'pointer'
                                      }}>
                                        <Text style={{ 
                                          fontSize: 9, 
                                          color: '#6b7280',
                                          fontWeight: '600'
                                        }}>
                                          +{remainingCount}
                                        </Text>
                                      </View>
                                    )}
                                  </>
                                );
                              })()}
                            </View>
                          </TouchableOpacity>
                        );
                      })}
      </View>
                  ));
                  })()
                )}
    </View>
        </View>
      </View>
            
            {/* Right Sidebar - Learning Tracks & Schedule */}
            <View style={{
              width: 320,
              backgroundColor: '#f8fafc',
              borderLeftWidth: 1,
              borderLeftColor: '#e1e5e9',
              padding: 12,
              height: '100vh',
              overflow: 'hidden'
            }}>
              {showNewEventForm ? (
                // New Event Form View
                <ScrollView 
                  style={{ flex: 1 }} 
                  contentContainerStyle={{ 
                    padding: 12,
                    paddingBottom: 60
                  }}
                  showsVerticalScrollIndicator={true}
                  bounces={false}
                  nestedScrollEnabled={true}
                >
                  {/* Close Button - Top Right */}
                  <TouchableOpacity 
                    onPress={closeNewEventForm}
                    style={{
                      position: 'absolute',
                      top: 12,
                      right: 12,
                      zIndex: 1000
                    }}
                  >
                    <Text style={{ fontSize: 16, color: '#6b7280' }}>âœ•</Text>
                  </TouchableOpacity>

                  {/* New Event Header */}
                  <View style={{ 
                    marginBottom: 16,
                    marginTop: 40
                  }}>
                    <View style={{ position: 'relative', marginBottom: showEventTypeDropdown ? 120 : 0 }}>
                      <TouchableOpacity
                        onPress={() => setShowEventTypeDropdown(!showEventTypeDropdown)}
                          style={{
                    flexDirection: 'row', 
                          alignItems: 'center',
                    justifyContent: 'space-between', 
                            backgroundColor: '#ffffff',
                            borderWidth: 1,
                            borderColor: '#e1e5e9',
                            borderRadius: 6,
                          padding: 8,
                          minWidth: 120
                        }}
                      >
                        <Text style={{ 
                          fontSize: 12, 
                            fontWeight: '600',
                            color: '#111827',
                          textTransform: 'capitalize'
                        }}>
                          {newEventType === 'holiday' ? 'Days Off' : newEventType}
                    </Text>
                        <Ionicons 
                          name={showEventTypeDropdown ? "chevron-up" : "chevron-down"} 
                          size={14} 
                          color="#6b7280" 
                        />
                      </TouchableOpacity>
                      
                      {showEventTypeDropdown && (
                          <View style={{
                            position: 'absolute',
                          top: '100%',
                          left: 0,
                          right: 0,
                          backgroundColor: '#ffffff',
                          borderWidth: 1,
                          borderColor: '#e1e5e9',
                          borderRadius: 6,
                          marginTop: 4,
                          zIndex: 9999,
                          shadowColor: '#000',
                          shadowOffset: { width: 0, height: 2 },
                          shadowOpacity: 0.1,
                          shadowRadius: 4,
                          elevation: 5
                        }}>
                          {['lesson', 'activity', 'holiday'].map((type) => (
                            <TouchableOpacity
                              key={type}
                              onPress={() => {
                                setNewEventType(type);
                                setShowEventTypeDropdown(false);
                              }}
                              style={{
                                padding: 12,
                                borderBottomWidth: type !== 'holiday' ? 1 : 0,
                                borderBottomColor: '#f3f4f6',
                                backgroundColor: newEventType === type ? '#f3f4f6' : 'transparent'
                              }}
                            >
                              <Text style={{
                                fontSize: 14,
                                color: newEventType === type ? '#1e40af' : '#374151',
                                fontWeight: newEventType === type ? '600' : '400',
                                textTransform: 'capitalize'
                              }}>
                                {type === 'holiday' ? 'Days Off' : type}
                    </Text>
                            </TouchableOpacity>
                          ))}
                          </View>
                      )}
                        </View>
                  </View>

                  {/* Title Section */}
                  <View style={{ marginBottom: 12 }}>
                    <View style={{ padding: 4 }}>
                        <TextInput
                          style={{
                            backgroundColor: '#ffffff',
                            borderWidth: 1,
                            borderColor: '#e1e5e9',
                            borderRadius: 6,
                            padding: 8,
                          fontSize: 12,
                          color: '#111827'
                        }}
                        placeholder="Title"
                        value={newEventFormData.title}
                        onChangeText={(text) => setNewEventFormData({...newEventFormData, title: text})}
                      />
                    </View>
                    </View>
                    
                  {/* Description Section */}
                  <View style={{ marginBottom: 12 }}>
                    <View style={{ padding: 4 }}>
                      <TextInput
                        style={{
                          backgroundColor: '#ffffff',
                          borderWidth: 1,
                          borderColor: '#e1e5e9',
                          borderRadius: 6,
                          padding: 8,
                          fontSize: 12,
                            color: '#111827',
                          minHeight: 60
                        }}
                        placeholder="Description"
                        value={newEventFormData.description}
                        onChangeText={(text) => setNewEventFormData({...newEventFormData, description: text})}
                        multiline
                        textAlignVertical="top"
                      />
                    </View>
                  </View>

                  {/* Date Selection Section - Different for holidays */}
                  {newEventType === 'holiday' ? (
                    <>
                      {/* Date Range Toggle */}
                      <View style={{ marginBottom: 12 }}>
                        <View style={{ padding: 4 }}>
                          <View style={{
                            flexDirection: 'row', 
                            alignItems: 'center',
                            gap: 8,
                            marginBottom: 8
                          }}>
                            <TouchableOpacity
                              onPress={() => setHolidayDateRange(prev => ({ ...prev, isRange: false }))}
                              style={{
                                paddingHorizontal: 8,
                                paddingVertical: 4,
                                borderRadius: 4,
                                backgroundColor: !holidayDateRange.isRange ? '#3b82f6' : '#f3f4f6',
                                borderWidth: 1,
                                borderColor: !holidayDateRange.isRange ? '#3b82f6' : '#d1d5db'
                              }}
                            >
                              <Text style={{ 
                                fontSize: 11, 
                                color: !holidayDateRange.isRange ? '#ffffff' : '#374151',
                                fontWeight: '500'
                              }}>
                                Single Day
                              </Text>
                      </TouchableOpacity>
                            <TouchableOpacity
                              onPress={() => setHolidayDateRange(prev => ({ ...prev, isRange: true }))}
                              style={{
                                paddingHorizontal: 8,
                                paddingVertical: 4,
                                borderRadius: 4,
                                backgroundColor: holidayDateRange.isRange ? '#3b82f6' : '#f3f4f6',
                                borderWidth: 1,
                                borderColor: holidayDateRange.isRange ? '#3b82f6' : '#d1d5db'
                              }}
                            >
                              <Text style={{ 
                                fontSize: 11, 
                                color: holidayDateRange.isRange ? '#ffffff' : '#374151',
                                fontWeight: '500'
                              }}>
                                Date Range
                              </Text>
                    </TouchableOpacity>
                          </View>
                    </View>
                  </View>

                      {/* Single Date Input */}
                      {!holidayDateRange.isRange && (
                        <View style={{ marginBottom: 12 }}>
                          <View style={{ padding: 4 }}>
                            <TextInput
                              style={{
                      backgroundColor: '#ffffff',
                      borderWidth: 1,
                      borderColor: '#e1e5e9',
                      borderRadius: 6,
                      padding: 8,
                                fontSize: 12,
                                color: '#111827'
                              }}
                              placeholder="Date (YYYY-MM-DD)"
                              value={newEventFormData.scheduledDate}
                              onChangeText={(text) => setNewEventFormData({...newEventFormData, scheduledDate: text})}
                            />
                          </View>
                    </View>
                  )}

                      {/* Date Range Inputs */}
                      {holidayDateRange.isRange && (
                        <>
                          <View style={{ marginBottom: 12 }}>
                            <View style={{ padding: 4 }}>
                              <TextInput
                      style={{
                                  backgroundColor: '#ffffff',
                        borderWidth: 1,
                                  borderColor: '#e1e5e9',
                        borderRadius: 6,
                                  padding: 8,
                                  fontSize: 12,
                                  color: '#111827'
                                }}
                                placeholder="Start Date (YYYY-MM-DD)"
                                value={holidayDateRange.startDate}
                                onChangeText={(text) => setHolidayDateRange(prev => ({ ...prev, startDate: text }))}
                              />
                            </View>
                          </View>
                          <View style={{ marginBottom: 12 }}>
                            <View style={{ padding: 4 }}>
                              <TextInput
                                style={{
                                  backgroundColor: '#ffffff',
                                  borderWidth: 1,
                                  borderColor: '#e1e5e9',
                                  borderRadius: 6,
                                  padding: 8,
                                  fontSize: 12,
                                  color: '#111827'
                                }}
                                placeholder="End Date (YYYY-MM-DD)"
                                value={holidayDateRange.endDate}
                                onChangeText={(text) => setHolidayDateRange(prev => ({ ...prev, endDate: text }))}
                              />
                            </View>
                          </View>
                        </>
                      )}

                      {/* Repeat Options */}
                      <View style={{ marginBottom: 12 }}>
                        <View style={{ padding: 4 }}>
                          <View style={{ 
                            flexDirection: 'row',
                            alignItems: 'center', 
                            justifyContent: 'space-between',
                            marginBottom: 8
                          }}>
                            <Text style={{ fontSize: 12, color: '#6b7280', fontWeight: '500' }}>
                              Repeat
                            </Text>
                            <TouchableOpacity
                              onPress={() => setHolidayRepeat(prev => ({ ...prev, enabled: !prev.enabled }))}
                              style={{
                                width: 32,
                                height: 16,
                                backgroundColor: holidayRepeat.enabled ? '#3b82f6' : '#d1d5db',
                                borderRadius: 8,
                                padding: 2
                              }}
                            >
                              <View style={{
                                width: 12,
                                height: 12,
                                backgroundColor: '#ffffff',
                                borderRadius: 6,
                                transform: [{ translateX: holidayRepeat.enabled ? 16 : 0 }]
                              }} />
                            </TouchableOpacity>
                          </View>
                    
                          {holidayRepeat.enabled && (
                            <View style={{ gap: 8 }}>
                              <View style={{
                                flexDirection: 'row', 
                                alignItems: 'center', 
                                gap: 4,
                                flexWrap: 'wrap'
                              }}>
                                {[
                                  { value: 'daily', label: 'Day' },
                                  { value: 'weekly', label: 'Week' },
                                  { value: 'biweekly', label: 'Two Weeks' },
                                  { value: 'monthly', label: 'Month' },
                                  { value: 'yearly', label: 'Year' }
                                ].map((freq) => (
                                  <TouchableOpacity 
                                    key={freq.value}
                                    onPress={() => setHolidayRepeat(prev => ({ ...prev, frequency: freq.value }))}
                                    style={{ 
                                      paddingHorizontal: 6,
                                      paddingVertical: 3,
                                      borderRadius: 6,
                                      backgroundColor: holidayRepeat.frequency === freq.value ? '#3b82f6' : '#ffffff',
                                      borderWidth: 1,
                                      borderColor: holidayRepeat.frequency === freq.value ? '#3b82f6' : '#e1e5e9',
                                      minWidth: 50,
                                      alignItems: 'center'
                                    }}
                                  >
                                    <Text style={{ 
                                      fontSize: 11, 
                                      color: holidayRepeat.frequency === freq.value ? '#ffffff' : '#111827',
                                      fontWeight: holidayRepeat.frequency === freq.value ? '500' : '400'
                                    }}>
                                      {freq.label}
                                    </Text>
                                  </TouchableOpacity>
                                ))}
                              </View>
                            </View>
                          )}
                        </View>
                      </View>
                  ) : (
                    <>
                      <View style={{ marginBottom: 12 }}>
                        <View style={{ padding: 4 }}>
                          <TextInput
                            style={{
                              backgroundColor: '#ffffff',
                              borderWidth: 1,
                              borderColor: '#e1e5e9',
                              borderRadius: 6,
                              padding: 8,
                              fontSize: 12,
                              color: '#111827'
                            }}
                            placeholder="Scheduled Date (YYYY-MM-DD)"
                            value={newEventFormData.scheduledDate}
                            onChangeText={(text) => setNewEventFormData({...newEventFormData, scheduledDate: text})}
                          />
                        </View>
                      </View>
                    </>
                  ) : (
                    <>
                      {/* Due Date Section - Only for lessons and activities */}
                    {newEventType !== 'holiday' && (
                      <View style={{ marginBottom: 12 }}>
                        <View style={{ padding: 4 }}>
                          <TextInput
                        style={{
                              backgroundColor: '#ffffff',
                                        borderWidth: 1,
                              borderColor: '#e1e5e9',
                          borderRadius: 6,
                              padding: 8,
                                          fontSize: 12, 
                              color: '#111827'
                            }}
                            placeholder="Due Date (YYYY-MM-DD, optional)"
                            value={newEventFormData.dueDate}
                            onChangeText={(text) => setNewEventFormData({...newEventFormData, dueDate: text})}
                          />
                                      </View>
                                  </View>
                    )}

                    {/* Scheduled Time Section - Only for lessons and activities */}
                    {newEventType !== 'holiday' && (
                      <View style={{ marginBottom: 12 }}>
                        <View style={{ padding: 4 }}>
                          <TextInput
                            style={{
                      backgroundColor: '#ffffff',
                      borderWidth: 1,
                      borderColor: '#e1e5e9',
                      borderRadius: 6,
                      padding: 8,
                                        fontSize: 12, 
                            color: '#111827'
                          }}
                          placeholder="Scheduled Time (e.g. 9:00 AM)"
                          value={newEventFormData.scheduledTime}
                          onChangeText={(text) => setNewEventFormData({...newEventFormData, scheduledTime: text})}
                        />
                              </View>
                      </View>
                  )}

                    {/* Finish Time Section - Only for lessons and activities */}
                    {newEventType !== 'holiday' && (
                      <View style={{ marginBottom: 12 }}>
                        <View style={{ padding: 4 }}>
                          <TextInput
                            style={{
                          backgroundColor: '#ffffff',
                          borderWidth: 1,
                          borderColor: '#e1e5e9',
                          borderRadius: 6,
                          padding: 8,
                              fontSize: 12,
                              color: '#111827'
                            }}
                            placeholder="Finish Time (e.g. 11:30 AM, optional)"
                            value={newEventFormData.finishTime}
                            onChangeText={(text) => setNewEventFormData({...newEventFormData, finishTime: text})}
                          />
                        </View>
                      </View>
                    )}

                    {/* Assignees Section - Only for lessons and activities */}
                    {newEventType !== 'holiday' && (
                      <View style={{ marginBottom: 12 }}>
                        <View style={{ padding: 4 }}>
                          <View style={{ gap: 4 }}>
                            {children.map((child) => (
                              <TouchableOpacity 
                                key={child.id}
                                onPress={() => {
                                  const isSelected = newEventFormData.assignees.includes(child.first_name);
                                  if (isSelected) {
                                    setNewEventFormData({
                                      ...newEventFormData,
                                      assignees: newEventFormData.assignees.filter(name => name !== child.first_name)
                                    });
                                  } else {
                                    setNewEventFormData({
                                      ...newEventFormData,
                                      assignees: [...newEventFormData.assignees, child.first_name]
                                    });
                                  }
                                }}
                                style={{ 
                                  flexDirection: 'row',
                                  alignItems: 'center',
                                  padding: 6,
                                  borderWidth: 1,
                                  borderColor: newEventFormData.assignees.includes(child.first_name) ? '#3b82f6' : '#d1d5db',
                                  borderRadius: 6,
                                  backgroundColor: newEventFormData.assignees.includes(child.first_name) ? '#eff6ff' : '#ffffff'
                                }}
                              >
                                <View style={{
                                  width: 14,
                                  height: 14,
                                  borderRadius: 3,
                                  borderWidth: 2,
                                  borderColor: newEventFormData.assignees.includes(child.first_name) ? '#3b82f6' : '#d1d5db',
                                  backgroundColor: newEventFormData.assignees.includes(child.first_name) ? '#3b82f6' : 'transparent',
                                  marginRight: 8,
                                  alignItems: 'center',
                                  justifyContent: 'center'
                                }}>
                                  {newEventFormData.assignees.includes(child.first_name) && (
                                    <Text style={{ color: '#ffffff', fontSize: 11, fontWeight: '600' }}>âœ“</Text>
                                  )}
                                </View>
                                <Text style={{ 
                                  fontSize: 12,
                                  color: newEventFormData.assignees.includes(child.first_name) ? '#1e40af' : '#374151'
                                }}>
                                  {child.first_name}
                                </Text>
                              </TouchableOpacity>
                            ))}
                          </View>
                        </View>
                      </View>
                    )}

                    {/* Status Section - Only for lessons and activities */}
                    {newEventType !== 'holiday' && (
                      <View style={{ marginBottom: 16 }}>
                        <View style={{ padding: 4, marginBottom: showStatusDropdown ? 120 : 0 }}>
                          <View style={{ position: 'relative', zIndex: 1000, width: '100%' }}>
                            <TouchableOpacity
                              onPress={() => setShowStatusDropdown(!showStatusDropdown)}
                              style={{
                                flexDirection: 'row', 
                                alignItems: 'center',
                                justifyContent: 'space-between', 
                                backgroundColor: '#ffffff',
                                borderWidth: 1,
                                borderColor: '#e1e5e9',
                                borderRadius: 6,
                                padding: 8,
                                fontSize: 12,
                                color: '#111827',
                                width: '100%'
                              }}
                            >
                              <Text style={{ 
                                fontSize: 12, 
                                color: '#111827', 
                                textTransform: 'capitalize'
                              }}>
                                {newEventFormData.status === 'planned' ? 'To Do' : newEventFormData.status.replace('_', ' ')}
                              </Text>
                              <Ionicons 
                                name={showStatusDropdown ? "chevron-up" : "chevron-down"} 
                                size={14} 
                                color="#6b7280" 
                              />
                            </TouchableOpacity>
                        
                            {showStatusDropdown && (
                              <View style={{ 
                                position: 'absolute',
                                top: '100%',
                                left: 0,
                                right: 0,
                                backgroundColor: '#ffffff',
                                borderWidth: 1,
                                borderColor: '#e1e5e9',
                                borderRadius: 6,
                                marginTop: 4,
                                zIndex: 99999,
                                shadowColor: '#000',
                                shadowOffset: { width: 0, height: 4 },
                                shadowOpacity: 0.15,
                                shadowRadius: 8,
                                elevation: 10
                              }}>
                                {['planned', 'in_progress', 'completed'].map((status) => (
                                  <TouchableOpacity 
                                    key={status}
                                    onPress={() => {
                                      setNewEventFormData({ ...newEventFormData, status });
                                      setShowStatusDropdown(false);
                                    }}
                                    style={{
                                      padding: 8,
                                      borderBottomWidth: status !== 'completed' ? 1 : 0,
                                      borderBottomColor: '#f3f4f6',
                                      backgroundColor: newEventFormData.status === status ? '#f3f4f6' : 'transparent'
                                    }}
                                  >
                                    <Text style={{ 
                                      fontSize: 12,
                                      color: newEventFormData.status === status ? '#1e40af' : '#374151',
                                      fontWeight: newEventFormData.status === status ? '500' : '400',
                                      textTransform: 'capitalize'
                                    }}>
                                      {status === 'planned' ? 'To Do' : status.replace('_', ' ')}
                                    </Text>
                                  </TouchableOpacity>
                                ))}
                              </View>
                            )}
                          </View>
                        </View>
                      </View>
                    )}
                  </>
                )}

                {/* Save Button */}
                <TouchableOpacity 
                  onPress={saveNewEventFromForm}
                  disabled={
                    !newEventFormData.title || 
                    isSaving || 
                    (newEventType === 'holiday' ? 
                      (holidayDateRange.isRange ? 
                        (!holidayDateRange.startDate || !holidayDateRange.endDate) : 
                        !newEventFormData.scheduledDate
                      ) : 
                      !newEventFormData.scheduledDate
                    )
                  }
                            style={{ 
                    backgroundColor: (
                      !newEventFormData.title || 
                      isSaving || 
                      (newEventType === 'holiday' ? 
                        (holidayDateRange.isRange ? 
                          (!holidayDateRange.startDate || !holidayDateRange.endDate) : 
                          !newEventFormData.scheduledDate
                        ) : 
                        !newEventFormData.scheduledDate
                      )
                    ) ? '#d1d5db' : '#3b82f6',
                    padding: 10,
                    borderRadius: 8,
                    alignItems: 'center',
                    marginTop: 12
                  }}
                >
                  {isSaving ? (
                    <ActivityIndicator color="#ffffff" />
                  ) : (
                    <Text style={{
                      color: '#ffffff',
                      fontSize: 14,
                      fontWeight: '600'
                    }}>
                      Create {newEventType === 'holiday' ? 'Days Off' : newEventType.charAt(0).toUpperCase() + newEventType.slice(1)}
                  </Text>
                  )}
                    </TouchableOpacity>
              </ScrollView>
            ) : selectedEvent ? (
              selectedEvent.type === 'holiday' ? (
                // Holiday Details View - Simplified
                <ScrollView 
                  style={{ flex: 1 }} 
                  contentContainerStyle={{ 
                    padding: 12,
                    paddingBottom: 60
                  }}
                  showsVerticalScrollIndicator={true}
                  bounces={false}
                  nestedScrollEnabled={true}
                >
                  {/* Close Button - Top Right */}
                      <TouchableOpacity 
                    onPress={handleCloseEvent}
                        style={{
                      position: 'absolute',
                      top: 12,
                      right: 12,
                      zIndex: 1000
                    }}
                  >
                    <Text style={{ fontSize: 16, color: '#6b7280' }}>âœ•</Text>
                      </TouchableOpacity>

                  {/* Holiday Header */}
                          <View style={{
                  marginBottom: 16,
                  marginTop: 40
                }}>
                  <Text style={{ fontSize: 18, fontWeight: '600', color: '#111827', marginBottom: 8 }}>
                    {selectedEvent.title}
                  </Text>
                </View>
                          
                  {/* Holiday Date */}
                  <View style={{ marginBottom: 12 }}>
                    <View style={{ padding: 4 }}>
                      <Text style={{ color: '#111827', fontSize: 12 }}>
                        {selectedEvent.data?.holiday_date ? new Date(selectedEvent.data.holiday_date).toLocaleDateString('en-US', { 
                          weekday: 'long', 
                          year: 'numeric', 
                          month: 'long', 
                          day: 'numeric' 
                        }) : 'Date not available'}
                      </Text>
                    </View>
                  </View>
                </ScrollView>
              ) : (
                // Event Details View - Matching Add Event Form Structure
                <ScrollView 
                  style={{ flex: 1 }} 
                  contentContainerStyle={{ 
                      padding: 12,
                    paddingBottom: 60
                  }}
                  showsVerticalScrollIndicator={true}
                  bounces={false}
                  nestedScrollEnabled={true}
                >
                  {/* Close Button - Top Right */}
                  <TouchableOpacity 
                    onPress={handleCloseEvent}
                    style={{
                      position: 'absolute',
                      top: 12,
                      right: 12,
                      zIndex: 1000
                    }}
                  >
                    <Text style={{ fontSize: 16, color: '#6b7280' }}>âœ•</Text>
                  </TouchableOpacity>



                {/* Title Section */}
                <View style={{ marginBottom: 12, marginTop: 40 }}>
                  <View style={{ padding: 4 }}>
                    {editingTitle ? (
                    <View>
                      <TextInput
                        style={{
                          backgroundColor: '#ffffff',
                          borderWidth: 1,
                          borderColor: '#e1e5e9',
                          borderRadius: 6,
                            padding: 8,
                            fontSize: 12,
                          color: '#111827',
                            marginBottom: 8,
                            minHeight: 32
                          }}
                          value={tempTitle}
                          onChangeText={setTempTitle}
                          placeholder="Title"
                        placeholderTextColor="#9ca3af"
                      />
                      <View style={{ flexDirection: 'row', gap: 8 }}>
                        <TouchableOpacity 
                          style={{
                            backgroundColor: '#10b981',
                              paddingHorizontal: 12,
                              paddingVertical: 6,
                              borderRadius: 4,
                            flex: 1
                          }}
                            onPress={handleTitleSave}
                          disabled={isSaving}
                        >
                          <Text style={{ 
                            color: 'white', 
                              fontSize: 12, 
                            textAlign: 'center', 
                            fontWeight: '500' 
                          }}>
                            {isSaving ? 'Saving...' : 'Save'}
                          </Text>
                        </TouchableOpacity>
                        <TouchableOpacity 
                          style={{
                            backgroundColor: '#f3f4f6',
                              paddingHorizontal: 12,
                              paddingVertical: 6,
                              borderRadius: 4,
                            flex: 1
                          }}
                            onPress={handleTitleCancel}
                          >
                                    <Text style={{ 
                              color: '#374151', 
                                      fontSize: 12, 
                              textAlign: 'center', 
                                      fontWeight: '500' 
                                    }}>
                              Cancel
                                    </Text>
                        </TouchableOpacity>
                      </View>
                    </View>
                  ) : (
                      <TouchableOpacity 
                        style={{
                          padding: 8,
                          cursor: Platform.OS === 'web' ? 'pointer' : 'default'
                        }}
                        onPress={handleTitleEdit}
                        activeOpacity={0.7}
                      >
                        <Text style={{ color: '#111827', fontSize: 12 }}>
                          {selectedEvent.data?.title || selectedEvent.title || 'No title'}
                    </Text>
                      </TouchableOpacity>
                  )}
                          </View>
                </View>

                {/* Status Section */}
                <View style={{ marginBottom: 12 }}>
                  <View style={{ padding: 4 }}>
                    {editingStatus ? (
                  <View style={{
                      backgroundColor: '#ffffff',
                    borderWidth: 1,
                      borderColor: '#e1e5e9',
                    borderRadius: 6,
                      padding: 8,
                        marginBottom: 8
                      }}>
                        {['planned', 'in_progress', 'completed', 'skipped'].map((status) => (
                          <TouchableOpacity 
                            key={status}
                            style={{ 
                  flexDirection: 'row',
                            alignItems: 'center',
                            paddingVertical: 6,
                            paddingHorizontal: 4
                          }}
                          onPress={() => setTempStatus(status)}
                        >
                          <View style={{
                            width: 6,
                            height: 6,
                            borderRadius: 3,
                            backgroundColor: getStatusColor(status),
                            marginRight: 8
                          }} />
                          <Text style={{ 
                            color: tempStatus === status ? '#111827' : '#6b7280',
                            fontSize: 12,
                            fontWeight: tempStatus === status ? '500' : '400'
                          }}>
                            {(() => {
                              switch(status) {
                                case 'planned': return 'To Do'
                                case 'in_progress': return 'In Progress'
                                case 'completed': return 'Completed'
                                case 'skipped': return 'Skipped'
                                default: return status.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())
                              }
                            })()}
                  </Text>
                        </TouchableOpacity>
                      ))}
                      <View style={{ flexDirection: 'row', gap: 8, marginTop: 8 }}>
                  <TouchableOpacity 
                    style={{
                            backgroundColor: '#10b981',
                      paddingHorizontal: 12,
                      paddingVertical: 6,
                            borderRadius: 4,
                            flex: 1
                          }}
                          onPress={handleStatusSave}
                          disabled={isSaving}
                        >
                          <Text style={{ 
                            color: 'white', 
                            fontSize: 12,
                            textAlign: 'center', 
                            fontWeight: '500' 
                          }}>
                            {isSaving ? 'Saving...' : 'Save'}
                        </Text>
                      </TouchableOpacity>
                      <TouchableOpacity 
                        style={{ 
                      backgroundColor: '#f3f4f6',
                      paddingHorizontal: 12,
                      paddingVertical: 6,
                            borderRadius: 4,
                            flex: 1
                          }}
                          onPress={handleStatusCancel}
                        >
                          <Text style={{ 
                            color: '#374151', 
                            fontSize: 12, 
                            textAlign: 'center', 
                            fontWeight: '500' 
                          }}>
                            Cancel
                        </Text>
                  </TouchableOpacity>
                </View>
              </View>
                  ) : (
                    <TouchableOpacity 
                      style={{
                        padding: 8,
                        cursor: Platform.OS === 'web' ? 'pointer' : 'default'
                      }}
                      onPress={handleStatusEdit}
                      activeOpacity={0.7}
                    >
                      <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                          <View style={{
                          width: 6,
                          height: 6,
                            borderRadius: 3,
                          backgroundColor: getStatusColor((selectedEvent.data?.status || selectedEvent.status) || 'planned'),
                          marginRight: 8
                        }} />
                        <Text style={{ color: '#111827', fontSize: 12 }}>
                          {(() => {
                            const currentStatus = (selectedEvent.data?.status || selectedEvent.status) || 'planned'
                            switch(currentStatus) {
                              case 'planned': return 'To Do'
                              case 'in_progress': return 'In Progress'
                              case 'completed': return 'Completed'
                              case 'skipped': return 'Skipped'
                              default: return currentStatus.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())
                            }
                          })()}
                </Text>
                          </View>
                        </TouchableOpacity>
                  )}
                      </View>
                </View>

                                {/* Time Range Section */}
                <View style={{ marginBottom: 12 }}>
                  <View style={{ padding: 4 }}>
                    {(editingScheduledTime || editingFinishTime) ? (
                    <View>
                        <View style={{ flexDirection: 'row', gap: 8, marginBottom: 8 }}>
                          {/* Start Time Input */}
                          <View style={{ flex: 1 }}>
                            <Text style={{ fontSize: 10, color: '#6b7280', marginBottom: 4 }}>Start Time</Text>
                            {Platform.OS === 'web' ? (
                  <View style={{
                      backgroundColor: '#ffffff',
                    borderWidth: 1,
                      borderColor: '#e1e5e9',
                    borderRadius: 6,
                      padding: 8,
                                minHeight: 32
                              }}>
                                <input
                                  type="time"
                                  value={tempScheduledTime}
                                  onChange={(e) => setTempScheduledTime(e.target.value)}
                            style={{ 
                                    border: 'none',
                                    outline: 'none',
                                    fontSize: 12,
                                    color: '#111827',
                                    backgroundColor: 'transparent',
                                    width: '100%',
                                    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'
                                  }}
                                />
                              </View>
                            ) : (
                  <TextInput
                    style={{
                      backgroundColor: '#ffffff',
                      borderWidth: 1,
                      borderColor: '#e1e5e9',
                      borderRadius: 6,
                              padding: 8,
                              fontSize: 12,
                    color: '#111827',
                              minHeight: 32
                            }}
                            value={tempScheduledTime}
                            onChangeText={setTempScheduledTime}
                            placeholder="9:00"
                    placeholderTextColor="#9ca3af"
                          />
                  )}
                        </View>
                                
                              {/* Finish Time Input */}
                              <View style={{ flex: 1 }}>
                                <Text style={{ fontSize: 10, color: '#6b7280', marginBottom: 4 }}>Finish Time</Text>
                                {Platform.OS === 'web' ? (
                                <View style={{
                                    backgroundColor: '#ffffff',
                                    borderWidth: 1,
                                    borderColor: '#e1e5e9',
                                    borderRadius: 6,
                                    padding: 8,
                                    minHeight: 32
                                  }}>
                                    <input
                                      type="time"
                                      value={tempFinishTime}
                                      onChange={(e) => setTempFinishTime(e.target.value)}
                                      style={{
                                        border: 'none',
                                        outline: 'none',
                                        fontSize: 12,
                              color: '#111827', 
                                        backgroundColor: 'transparent',
                                        width: '100%',
                                        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'
                                      }}
                                    />
                                  </View>
                                ) : (
                                  <TextInput
                                    style={{
                                      backgroundColor: '#ffffff',
                                      borderWidth: 1,
                                      borderColor: '#e1e5e9',
                                      borderRadius: 6,
                                      padding: 8,
                                      fontSize: 12,
                                      color: '#111827',
                                      minHeight: 32
                                    }}
                                    value={tempFinishTime}
                                    onChangeText={setTempFinishTime}
                                    placeholder="10:30"
                                    placeholderTextColor="#9ca3af"
                                  />
                                )}
                              </View>
                    </View>
                            
                          <View style={{ flexDirection: 'row', gap: 8 }}>
                            <TouchableOpacity 
                              style={{
                                backgroundColor: '#10b981',
                                  paddingHorizontal: 12,
                                  paddingVertical: 6,
                                  borderRadius: 4,
                                flex: 1
                              }}
                              onPress={async () => {
                                  // Save both times
                                  await handleScheduledTimeSave()
                                  await handleFinishTimeSave()
                              }}
                              disabled={isSaving}
                            >
                              <Text style={{ 
                                color: 'white', 
                                  fontSize: 12, 
                                textAlign: 'center', 
                                fontWeight: '500' 
                              }}>
                                {isSaving ? 'Saving...' : 'Save'}
                            </Text>
                            </TouchableOpacity>
                        <TouchableOpacity 
                          style={{
                              backgroundColor: '#f3f4f6',
                            paddingHorizontal: 12,
                            paddingVertical: 6,
                                  borderRadius: 4,
                                flex: 1
                          }}
                          onPress={() => {
                                  handleScheduledTimeCancel()
                                  handleFinishTimeCancel()
                                }}
                              >
                                <Text style={{ 
                                  color: '#374151', 
                                  fontSize: 12, 
                                  textAlign: 'center', 
                                  fontWeight: '500'
                                }}>
                                  Cancel
                            </Text>
                          </TouchableOpacity>
                        </View>
                      </View>
                    ) : (
                        <TouchableOpacity
                          style={{
                            padding: 8,
                            cursor: Platform.OS === 'web' ? 'pointer' : 'default'
                          }}
                          onPress={() => {
                            handleScheduledTimeEdit()
                            handleFinishTimeEdit()
                          }}
                          activeOpacity={0.7}
                        >
                          <View style={{ flexDirection: 'row', alignItems: 'center', gap: 15 }}>
                            {/* Start Time Display */}
                            <View style={{ flexShrink: 0 }}>
                              <Text style={{ fontSize: 10, color: '#6b7280', marginBottom: 1 }}>Start</Text>
                              <Text style={{ color: '#111827', fontSize: 12 }}>
                                {selectedEvent.data?.scheduled_time ? (() => {
                                  const time = selectedEvent.data.scheduled_time
                                  const timeMatch = time.match(/(\d{1,2}):(\d{2})(?::\d{2})?\s*(AM|PM)?/i)
                                  if (timeMatch) {
                                    let hours = parseInt(timeMatch[1])
                                    const minutes = timeMatch[2]
                                    const period = timeMatch[3]?.toUpperCase()
                                    
                                    if (!period) {
                                      if (hours >= 12) {
                                        if (hours > 12) hours -= 12
                                        return `${hours}:${minutes} PM`
                                      } else {
                                        if (hours === 0) hours = 12
                                        return `${hours}:${minutes} AM`
                                      }
                                    } else {
                                      return `${hours}:${minutes} ${period}`
                                    }
                                  }
                                  return time
                                })() : 'Set time'}
                    </Text>
                </View>

                          {/* Arrow */}
                          <Text style={{ color: '#6b7280', fontSize: 12, marginHorizontal: 0 }}>â†’</Text>

                          {/* Finish Time Display */}
                          <View style={{ flexShrink: 0 }}>
                            <Text style={{ fontSize: 10, color: '#6b7280', marginBottom: 1 }}>Finish</Text>
                            <Text style={{ color: '#111827', fontSize: 12 }}>
                              {(() => {
                                const finishTime = selectedEvent.data?.finish_time
                                if (finishTime) {
                                  // Format finish time to AM/PM format
                                  const timeMatch = finishTime.match(/(\d{1,2}):(\d{2})(?::\d{2})?\s*(AM|PM)?/i)
                                  if (timeMatch) {
                                    let hours = parseInt(timeMatch[1])
                                    const minutes = timeMatch[2]
                                    const period = timeMatch[3]?.toUpperCase()
                                    
                                    // If no period provided, determine AM/PM from 24-hour format
                                    if (!period) {
                                      if (hours >= 12) {
                                        if (hours > 12) hours -= 12
                                        return `${hours}:${minutes} PM`
                                      } else {
                                        if (hours === 0) hours = 12
                                        return `${hours}:${minutes} AM`
                                      }
                                    } else {
                                      // Period already provided, just format
                                      return `${hours}:${minutes} ${period}`
                                    }
                                  }
                                  return finishTime
                                } else {
                                  const scheduledTime = selectedEvent.data?.scheduled_time || selectedEvent.scheduled_time
                                  const timeEstimate = selectedEvent.data?.minutes || selectedEvent.estimateMinutes || 0
                                  if (scheduledTime && timeEstimate > 0) {
                                    const calculatedFinishTime = calculateFinishTime(scheduledTime, timeEstimate)
                                    return calculatedFinishTime || 'Auto-calc'
                                  } else {
                                    return 'Set time'
                                  }
                                }
                              })()}
                  </Text>
                          </View>

                          {/* Duration Display */}
                          <View style={{ flexShrink: 0, alignSelf: 'flex-end' }}>
                            <Text style={{ color: '#9ca3af', fontSize: 12 }}>
                              {(() => {
                                const timeEstimate = selectedEvent.data?.minutes || selectedEvent.estimateMinutes || 0
                                if (timeEstimate > 0) {
                                  if (timeEstimate >= 60) {
                                    const hours = Math.floor(timeEstimate / 60)
                                    const minutes = timeEstimate % 60
                                    if (minutes === 0) {
                                      return `${hours}h`
                                    } else {
                                      // Calculate decimal hours properly (e.g., 30 minutes = 0.5 hours)
                                      const decimalHours = (timeEstimate / 60).toFixed(1)
                                      return `${decimalHours}h`
                                    }
                                  } else {
                                    return `${timeEstimate}m`
                                  }
                                }
                                return ''
                              })()}
                            </Text>
                          </View>

                        </View>
                      </TouchableOpacity>
                    )}
                  </View>
                </View>

                                {/* Date Range Section */}
                <View style={{ marginBottom: 12 }}>
                  <View style={{ padding: 4 }}>
                    {(editingScheduledDate || editingDueDate) ? (
                    <View>
                        <View style={{ flexDirection: 'row', gap: 8, marginBottom: 8 }}>
                          {/* Start Date Input */}
                          <View style={{ flex: 1 }}>
                            <Text style={{ fontSize: 10, color: '#6b7280', marginBottom: 4 }}>Start Date</Text>
                      <TextInput
                        style={{
                          backgroundColor: '#ffffff',
                      borderWidth: 1,
                          borderColor: '#e1e5e9',
                      borderRadius: 6,
                            padding: 8,
                            fontSize: 12,
                          color: '#111827',
                            minHeight: 32,
                            textAlign: 'left',
                            letterSpacing: 2
                          }}
                          value={tempScheduledDate}
                          onChangeText={(text) => {
                            // Handle backspace - if user is deleting, allow clearing the entire field
                            if (text.length < tempScheduledDate.length) {
                              // User is deleting - allow them to clear the field completely
                              setTempScheduledDate(text)
                              return
                            }
                            
                            // Format as MM/DD/YY with automatic slashes
                            let formatted = text.replace(/\D/g, '') // Remove non-digits
                            
                            if (formatted.length >= 2) {
                              formatted = formatted.substring(0, 2) + '/' + formatted.substring(2)
                            }
                            if (formatted.length >= 5) {
                              formatted = formatted.substring(0, 5) + '/' + formatted.substring(5, 7)
                            }
                            
                            setTempScheduledDate(formatted)
                          }}
                          placeholder="MM/DD/YY"
                        placeholderTextColor="#9ca3af"
                          maxLength={8}
                          keyboardType="numeric"
                        />
                          </View>

                          {/* Due Date Input */}
                          <View style={{ flex: 1 }}>
                            <Text style={{ fontSize: 10, color: '#6b7280', marginBottom: 4 }}>Due Date</Text>
                            <TextInput
                              style={{
                                backgroundColor: '#ffffff',
                                borderWidth: 1,
                                borderColor: '#e1e5e9',
                                borderRadius: 6,
                                padding: 8,
                                fontSize: 12,
                                color: '#111827',
                                minHeight: 32,
                                textAlign: 'left',
                                letterSpacing: 2
                              }}
                              value={tempDueDate}
                              onChangeText={(text) => {
                                // Handle backspace - if user is deleting, allow clearing the entire field
                                if (text.length < tempDueDate.length) {
                                  // User is deleting - allow them to clear the field completely
                                  setTempDueDate(text)
                                  return
                                }
                                
                                // Format as MM/DD/YY with automatic slashes
                                let formatted = text.replace(/\D/g, '') // Remove non-digits
                                
                                if (formatted.length >= 2) {
                                  formatted = formatted.substring(0, 2) + '/' + formatted.substring(2)
                                }
                                if (formatted.length >= 5) {
                                  formatted = formatted.substring(0, 5) + '/' + formatted.substring(5, 7)
                                }
                                
                                setTempDueDate(formatted)
                              }}
                              placeholder="MM/DD/YY"
                              placeholderTextColor="#9ca3af"
                              maxLength={8}
                              keyboardType="numeric"
                            />
                          </View>
                        </View>

                      <View style={{ flexDirection: 'row', gap: 8 }}>
                        <TouchableOpacity 
                          style={{
                            backgroundColor: '#10b981',
                              paddingHorizontal: 12,
                              paddingVertical: 6,
                              borderRadius: 4,
                              flex: 1
                            }}
                            onPress={async () => {
                                // Save both dates
                                await handleScheduledDateSave()
                                await handleDueDateSave()
                            }}
                            disabled={isSaving}
                          >
                            <Text style={{ 
                              color: 'white', 
                              fontSize: 12, 
                              textAlign: 'center', 
                              fontWeight: '500' 
                            }}>
                              {isSaving ? 'Saving...' : 'Save'}
                        </Text>
                          </TouchableOpacity>
                        <TouchableOpacity 
                          style={{
                              backgroundColor: '#f3f4f6',
                            paddingHorizontal: 12,
                            paddingVertical: 6,
                              borderRadius: 4,
                            flex: 1
                          }}
                          onPress={() => {
                                handleScheduledDateCancel()
                                handleDueDateCancel()
                              }}
                            >
                              <Text style={{ 
                                color: '#374151', 
                                fontSize: 12, 
                                textAlign: 'center', 
                                fontWeight: '500' 
                              }}>
                                Cancel
                              </Text>
                        </TouchableOpacity>
                      </View>
                    </View>
                  </View>
                  </View>

                  {/* Assignee Section */}
                  <View style={{ marginBottom: 12 }}>
                    <View style={{ padding: 4 }}>
                      {editingAssignee ? (
                    <View style={{
                          backgroundColor: '#ffffff',
                      borderWidth: 1,
                          borderColor: '#e1e5e9',
                      borderRadius: 6,
                          padding: 8,
                          marginBottom: 8
                    }}>
                          {/* Children options */}
                          {children.map(child => (
                      <TouchableOpacity 
                              key={child.id}
                        style={{
                      flexDirection: 'row',
                                alignItems: 'center',
                          paddingVertical: 6,
                                paddingHorizontal: 4
                        }}
                        onPress={() => {
                                const assignee = child.first_name
                                if (tempAssignee.includes(assignee)) {
                                  setTempAssignee(tempAssignee.filter(a => a !== assignee))
                                } else {
                                  setTempAssignee([...tempAssignee, assignee])
                                }
                              }}
                            >
                    <View style={{
                                width: 14,
                                height: 14,
                      borderWidth: 1,
                      borderColor: '#d1d5db',
                                borderRadius: 3,
                                marginRight: 8,
                                backgroundColor: tempAssignee.includes(child.first_name) ? '#3b82f6' : 'transparent',
                                alignItems: 'center',
                                justifyContent: 'center'
                              }}>
                                {tempAssignee.includes(child.first_name) && (
                                  <Text style={{ color: 'white', fontSize: 10, fontWeight: 'bold' }}>âœ“</Text>
                                )}
                              </View>
                              <Text style={{ 
                                color: tempAssignee.includes(child.first_name) ? '#111827' : '#6b7280',
                                fontSize: 12,
                                fontWeight: tempAssignee.includes(child.first_name) ? '500' : '400'
                              }}>
                                {child.first_name}
                      </Text>
                            </TouchableOpacity>
                          ))}
                          
                          {/* Parent option */}
                      <TouchableOpacity 
                        style={{
                              flexDirection: 'row',
                              alignItems: 'center',
                          paddingVertical: 6,
                              paddingHorizontal: 4
                        }}
                        onPress={() => {
                              const assignee = 'Parent'
                              if (tempAssignee.includes(assignee)) {
                                setTempAssignee(tempAssignee.filter(a => a !== assignee))
                              } else {
                                setTempAssignee([...tempAssignee, assignee])
                              }
                            }}
                          >
                      <View style={{
                              width: 14,
                              height: 14,
                        borderWidth: 1,
                        borderColor: '#d1d5db',
                              borderRadius: 3,
                              marginRight: 8,
                              backgroundColor: tempAssignee.includes('Parent') ? '#3b82f6' : 'transparent',
                              alignItems: 'center',
                              justifyContent: 'center'
                            }}>
                              {tempAssignee.includes('Parent') && (
                                <Text style={{ color: 'white', fontSize: 10, fontWeight: 'bold' }}>âœ“</Text>
                              )}
                    </View>
                            <Text style={{ 
                              color: tempAssignee.includes('Parent') ? '#111827' : '#6b7280',
                              fontSize: 12,
                              fontWeight: tempAssignee.includes('Parent') ? '500' : '400'
                            }}>
                              Parent
                        </Text>
                          </TouchableOpacity>
                          
                          {/* Clear All option */}
                        <TouchableOpacity 
                          style={{
                      flexDirection: 'row',
                              alignItems: 'center',
                            paddingVertical: 6,
                              paddingHorizontal: 4,
                              borderTopWidth: 1,
                              borderTopColor: '#e5e7eb',
                              marginTop: 8,
                              paddingTop: 8
                            }}
                            onPress={() => setTempAssignee([])}
                          >
                            <Text style={{ 
                              color: '#dc2626', 
                              fontSize: 12,
                              fontWeight: '500'
                            }}>
                              Clear All Assignees
                      </Text>
                        </TouchableOpacity>

                          <View style={{ flexDirection: 'row', gap: 8, marginTop: 8 }}>
                        <TouchableOpacity
                          style={{
                            backgroundColor: '#10b981',
                          paddingHorizontal: 12,
                          paddingVertical: 6,
                                borderRadius: 4,
                            flex: 1
                          }}
                              onPress={handleAssigneeSave}
                              disabled={isSaving}
                            >
                              <Text style={{ 
                                color: 'white', 
                                fontSize: 12, 
                                textAlign: 'center', 
                                fontWeight: '500' 
                              }}>
                                {isSaving ? 'Saving...' : 'Save'}
                          </Text>
                        </TouchableOpacity>
                        <TouchableOpacity
                          style={{
                                backgroundColor: '#f3f4f6',
                          paddingHorizontal: 12,
                          paddingVertical: 6,
                                borderRadius: 4,
                            flex: 1
                          }}
                              onPress={handleAssigneeCancel}
                            >
                              <Text style={{ 
                                color: '#374151', 
                                fontSize: 12, 
                                textAlign: 'center', 
                                fontWeight: '500' 
                              }}>
                            Cancel
                          </Text>
                        </TouchableOpacity>
                          </View>
                        </View>
                    ) : (
                      <TouchableOpacity
                        style={{
                            padding: 8,
                            cursor: Platform.OS === 'web' ? 'pointer' : 'default'
                          }}
                          onPress={handleAssigneeEdit}
                          activeOpacity={0.7}
                        >
                          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                            <UserCircle size={14} color="#6b7280" style={{ marginRight: 8 }} />
                            <Text style={{ color: '#111827', fontSize: 12 }}>
                              {(() => {
                                const assignees = getCurrentAssignees()
                                if (assignees.length === 0) return 'Not assigned'
                                return assignees.join(', ')
                              })()}
                        </Text>
                          </View>
                      </TouchableOpacity>
                    )}
                    </View>
                  </View>

                  {/* Description Section */}
                  <View style={{ marginBottom: 12 }}>
                    <View style={{ padding: 4 }}>
                    {isEditingEvent ? (
                      <View>
                        <TextInput
                          style={{
                            backgroundColor: '#ffffff',
                            borderWidth: 1,
                            borderColor: '#e1e5e9',
                          borderRadius: 6,
                              padding: 8,
                              fontSize: 12,
                            color: '#111827',
                              minHeight: 60,
                            textAlignVertical: 'top',
                              marginBottom: 8
                          }}
                            value={editedEventData.description || selectedEvent.data?.description || selectedEvent.description || ''}
                          onChangeText={(text) => setEditedEventData({...editedEventData, description: text})}
                            placeholder="Description"
                          placeholderTextColor="#9ca3af"
                          multiline={true}
                          numberOfLines={4}
                        />
                        <View style={{ flexDirection: 'row', gap: 8 }}>
                        <TouchableOpacity
                          style={{
                            backgroundColor: '#10b981',
                                paddingHorizontal: 12,
                                paddingVertical: 6,
                                borderRadius: 4,
                          flex: 1
                        }}
                            onPress={async () => {
                                const newDescription = editedEventData.description || selectedEvent.data?.description || selectedEvent.description || '';
                              await handleDescriptionChange(newDescription);
                              setIsEditingEvent(false);
                              setEditedEventData({});
                            }}
                            disabled={isSaving}
                          >
                            <Text style={{ 
                              color: 'white', 
                                fontSize: 12, 
                              textAlign: 'center', 
                              fontWeight: '500' 
                            }}>
                              {isSaving ? 'Saving...' : 'Save'}
                          </Text>
                        </TouchableOpacity>
                        <TouchableOpacity
                          style={{
                              backgroundColor: '#f3f4f6',
                                paddingHorizontal: 12,
                                paddingVertical: 6,
                                borderRadius: 4,
                            flex: 1
                          }}
                            onPress={() => {
                              setIsEditingEvent(false);
                              setEditedEventData({});
                            }}
                        >
                              <Text style={{ color: '#6b7280', fontSize: 12, textAlign: 'center' }}>Cancel</Text>
                        </TouchableOpacity>
                        </View>
                      </View>
                    ) : (
                      <TouchableOpacity
                        style={{
                            padding: 8,
                            cursor: Platform.OS === 'web' ? 'pointer' : 'default'
                          }}
                          onPress={() => setIsEditingEvent(true)}
                          activeOpacity={0.7}
                        >
                      <Text style={{ 
                            fontSize: 12, 
                            color: (selectedEvent.data?.description || selectedEvent.description) ? '#111827' : '#9ca3af',
                            fontStyle: (selectedEvent.data?.description || selectedEvent.description) ? 'normal' : 'italic',
                            lineHeight: 16
                          }}>
                            {selectedEvent.data?.description || selectedEvent.description || 'Description'}
                        </Text>
                      </TouchableOpacity>
                    )}
                  </View>
                </View>

                </ScrollView>
                )
              ) : (
                // Default Right Pane Content
                <ScrollView 
                  showsVerticalScrollIndicator={true}
                  contentContainerStyle={{ paddingBottom: 20 }}
                  nestedScrollEnabled={true}
                  style={{ flex: 1 }}
                >
                                {/* Search Section */}
                <View style={{ marginTop: 20, marginBottom: 24 }}>
                  <View style={{
                    backgroundColor: '#ffffff',
                    borderRadius: 8,
                    borderWidth: 1,
                    borderColor: '#e1e5e9',
                    paddingHorizontal: 16,
                    paddingVertical: 8,
                    boxShadow: '0 1px 2px rgba(0, 0, 0, 0.05)',
                    elevation: 1
                  }}>
                    <TextInput
                      style={{ 
                        fontSize: 14, 
                        color: '#374151',
                        backgroundColor: 'transparent',
                        borderWidth: 0,
                        padding: 0,
                        margin: 0,
                        outline: 'none'
                      }}
                      placeholder="Search events"
                      placeholderTextColor="#9ca3af"
                      value={searchQuery}
                      onChangeText={setSearchQuery}
                      onSubmitEditing={handleSearch}
                    />
                  </View>
                {searchQuery.length > 0 && (
                  <TouchableOpacity 
                    onPress={() => setSearchQuery('')}
                    style={{
                      position: 'absolute',
                      right: 16,
                      top: 6,
                      padding: 4
                    }}
                  >
                    <Text style={{ color: '#9ca3af', fontSize: 16 }}>âœ•</Text>
                  </TouchableOpacity>
                )}
              </View>
              
              {/* Search Results Section - Fixed Height Container */}
              {searchQuery.length > 0 && (
                <View style={{ 
                  height: 'calc(100vh - 120px)', // Fixed height minus padding and header
                  overflow: 'hidden'
                }}>
                  <Text style={{
                    fontSize: 16,
                    fontWeight: '600',
                    color: '#111827',
                    marginBottom: 12
                  }}>
                    Search Results
                  </Text>
                  {isSearching ? (
                    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
                    <Text style={{ color: '#6b7280', textAlign: 'center' }}>Searching...</Text>
                    </View>
                  ) : searchResults.length > 0 ? (
                    <ScrollView 
                      style={{ height: 'calc(100vh - 180px)' }} // Fixed height for scrollable area
                      showsVerticalScrollIndicator={true}
                      contentContainerStyle={{ paddingBottom: 20 }}
                    >
                    <View style={{ gap: 8 }}>
                      {searchResults.map((result, index) => (
                        <TouchableOpacity
                          key={`search-result-${index}`}
                          style={{
                            backgroundColor: '#ffffff',
                            borderRadius: 6,
                            padding: 12,
                            borderWidth: 1,
                            borderColor: '#e1e5e9'
                          }}
                          onPress={() => {
                            handleEventSelect(result);
                          }}
                        >
                          <Text style={{
                            fontSize: 14,
                            fontWeight: '500',
                            color: '#111827',
                            marginBottom: 4
                          }}>
                            {result.title}
                          </Text>
                          <Text style={{
                            fontSize: 12,
                            color: '#6b7280'
                          }}>
                            {result.type} â€¢ {result.childName} â€¢ {result.date}
                          </Text>
                        </TouchableOpacity>
                      ))}
                    </View>
                    </ScrollView>
                  ) : (
                    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
                    <Text style={{ color: '#6b7280', textAlign: 'center' }}>
                      No results found
                    </Text>
                    </View>
                  )}
                </View>
              )}
              

              
                                {/* Today's Schedule Section - Only show when no search is active */}
                  {!searchQuery && (
                    <View style={{ marginTop: 20 }}>
                      <Text style={{
                        fontSize: 14,
                        color: '#6b7280',
                        textAlign: 'left'
                      }}>
                        Nothing scheduled for today
                      </Text>
                    </View>
                  )}
                </ScrollView>
              )}
            </View>
          </View>
        )
  }
      
  const renderCalendarPlanningContent = () => {
    if (!familyId) {
        return (
          <View style={styles.content}>
          <Text style={styles.title}>Calendar Planning</Text>
          <Text style={styles.subtitle}>Loading family information...</Text>
          </View>
        )
    }
      
        return (
          <View style={styles.content}>
        <CalendarPlanning 
          familyId={familyId}
          academicYear={null}
          showOnboardingBanner={false}
          onBack={() => onTabChange('calendar')}
        />
          </View>
        )
  }
      
  const renderAddOptionsContent = () => {
        return (
          <View style={styles.content}>
        <AddOptions
          onBack={() => onTabChange('home')}
          onAddSyllabus={() => onTabChange('syllabus')}
          onAddActivity={() => onTabChange('add-activity')}
          onAddChild={() => onTabChange('add-child')}
        />
          </View>
        )
  }
      
  const renderAddActivityContent = () => {
    if (!familyId) {
        return (
          <View style={styles.content}>
          <Text style={styles.title}>Add Activity</Text>
          <Text style={styles.subtitle}>Loading family information...</Text>
          </View>
        )
    }
      
        return (
          <View style={styles.content}>
        <AddActivityForm
          familyId={familyId}
          onBack={() => onTabChange('add-options')}
          onActivityAdded={(activity) => {
            console.log('Activity added:', activity);
            // Could refresh activities list here if needed
          }}
        />
          </View>
        )
  }

  return (
    <View style={styles.container}>
      {renderContent()}
      
      {/* Syllabus Upload Modal */}
      <SyllabusUpload
        visible={showSyllabusModal}
        onClose={handleCloseSyllabusUpload}
        onSyllabusProcessed={handleSyllabusProcessed}
      />

      {/* Coming Soon Modal */}
      <Modal
        visible={showComingSoonModal}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setShowComingSoonModal(false)}
      >
        <View style={{
          flex: 1,
          backgroundColor: 'rgba(0, 0, 0, 0.5)',
          justifyContent: 'center',
          alignItems: 'center',
          padding: 20,
        }}>
          <View style={{
            backgroundColor: '#ffffff',
            borderRadius: 16,
            padding: 24,
            width: '100%',
            maxWidth: 400,
            shadowColor: '#000',
            shadowOffset: {
              width: 0,
              height: 4,
            },
            shadowOpacity: 0.25,
            shadowRadius: 8,
            elevation: 8,
          }}>
            {/* Header */}
            <View style={{
              alignItems: 'center',
              marginBottom: 20,
            }}>
              <Text style={{
                fontSize: 24,
                fontWeight: '700',
                color: '#111827',
                marginBottom: 8
              }}>
                Coming Soon!
              </Text>
              <Text style={{
                fontSize: 16,
                color: '#6b7280',
                textAlign: 'center',
                lineHeight: 22
              }}>
                Doodle Suggestions will be available soon. We're working hard to bring you AI-powered learning recommendations.
              </Text>
            </View>

            {/* Close Button */}
            <TouchableOpacity
              onPress={() => setShowComingSoonModal(false)}
              style={{
                backgroundColor: '#3b82f6',
                padding: 16,
                borderRadius: 12,
                alignItems: 'center',
                marginTop: 8
              }}
            >
              <Text style={{
                color: '#ffffff',
                fontSize: 16,
                fontWeight: '600'
              }}>
                Got it!
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

          </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#ffffff',
  },
  content: {
    flex: 1,
    padding: 32,
    backgroundColor: '#ffffff',
  },
  grid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 16,
  },
  card: {
    width: '48%',
    borderRadius: 16,
    padding: 16,
    backgroundColor: '#fff',
    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
    borderWidth: 1,
    borderColor: '#f0f0f0',
    marginBottom: 16,
  },
  cardBlue: { backgroundColor: '#eef6ff' },
  cardPink: { backgroundColor: '#fff0f5' },
  cardGreen: { backgroundColor: '#f0fff4' },
  cardYellow: { backgroundColor: '#fffbea' },
  cardTitle: { fontSize: 18, fontWeight: '700', color: '#333', marginBottom: 8 },
  taskColumns: { flexDirection: 'row', gap: 12 },
  taskColumn: { flex: 1 },
  taskColumnTitle: { fontWeight: '600', color: '#555', marginBottom: 6 },
  taskItem: { flexDirection: 'row', alignItems: 'center', gap: 8, backgroundColor: '#fff', padding: 8, borderRadius: 8, borderWidth: 1, borderColor: '#eaeaea', marginBottom: 6 },
  checkbox: { width: 16, height: 16, borderRadius: 4, borderWidth: 1, borderColor: '#bbb', backgroundColor: '#fff' },
  taskText: { color: '#333' },
  primaryBtn: { backgroundColor: '#38B6FF', paddingVertical: 10, paddingHorizontal: 12, borderRadius: 10, alignSelf: 'flex-start', marginBottom: 8 },
  primaryBtnText: { color: '#fff', fontWeight: '700' },
  innerSearch: { borderWidth: 1, borderColor: '#e1e1e1', borderRadius: 8, paddingHorizontal: 10, paddingVertical: 8, backgroundColor: '#fff', marginBottom: 8 },
  progressRow: { flexDirection: 'row', alignItems: 'center', gap: 12 },
  progressCircle: { width: 64, height: 64, borderRadius: 32, borderWidth: 6, borderColor: '#38B6FF', backgroundColor: '#e6f4ff' },
  bulletLine: { color: '#555', marginTop: 2 },
  detailLine: { color: '#333' },
  scrollContainer: {
    flex: 1,
  },
  title: {
    fontSize: 32,
    fontWeight: '700',
    color: '#1a1a1a',
    marginBottom: 8,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
    letterSpacing: '-0.02em',
  },
  subtitle: {
    fontSize: 18,
    fontWeight: '400',
    color: '#666666',
    marginBottom: 32,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
    lineHeight: 26,
  },
  section: {
    marginBottom: 32,
  },
  sectionTitle: {
    fontSize: 24,
    fontWeight: '600',
    color: '#1a1a1a',
    marginBottom: 24,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
    letterSpacing: '-0.01em',
  },
  sectionSubtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 16,
  },


  form: {
    marginBottom: 24,
  },
  inputLabel: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    backgroundColor: '#fff',
    marginBottom: 16,
  },
  avatarGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  avatarOption: {
    width: 60,
    height: 60,
    borderRadius: 30,
    borderWidth: 2,
    borderColor: '#ddd',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  avatarOptionSelected: {
    borderColor: '#38B6FF',
    boxShadow: '0 2px 8px rgba(56, 182, 255, 0.3)',
  },
  avatarImage: {
    width: 50,
    height: 50,
    borderRadius: 25,
  },
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  checkboxLabel: {
    fontSize: 16,
    color: '#333',
    marginRight: 12,
  },
  checkbox: {
    width: 20,
    height: 20,
    borderWidth: 2,
    borderColor: '#ddd',
    borderRadius: 4,
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkboxChecked: {
    backgroundColor: '#38B6FF',
    borderColor: '#38B6FF',
  },
  checkboxText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: 'bold',
  },
  button: {
    backgroundColor: '#38B6FF',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginBottom: 16,
  },
  disabledButton: {
    backgroundColor: '#ccc',
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  childrenList: {
    marginTop: 24,
  },
  childCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    borderWidth: 1,
    borderColor: 'transparent',
  },
  childCardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  childAvatar: {
    width: 50,
    height: 50,
    borderRadius: 25,
    marginRight: 12,
  },
  childInfo: {
    flex: 1,
  },
  childName: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  childDetails: {
    fontSize: 14,
    color: '#666',
  },
  emptyState: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 80,
  },
  emptyTitle: {
    fontSize: 28,
    fontWeight: '600',
    color: '#1a1a1a',
    marginBottom: 16,
    textAlign: 'center',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  emptySubtitle: {
    fontSize: 16,
    color: '#666666',
    marginBottom: 32,
    textAlign: 'center',
    maxWidth: 400,
    lineHeight: 24,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  chatContainer: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    borderWidth: 1,
    borderColor: '#f1f3f4',
    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04), 0 1px 3px rgba(0, 0, 0, 0.06)',
    overflow: 'hidden',
  },
  messagesContainer: {
    minHeight: 400,
    padding: 24,
    backgroundColor: '#fafbfc',
  },
  welcomeMessage: {
    alignItems: 'center',
    paddingVertical: 20,
  },
  welcomeTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  welcomeText: {
    fontSize: 16,
    color: '#666',
    marginBottom: 8,
    textAlign: 'center',
  },
  welcomeBullet: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  message: {
    marginBottom: 20,
    padding: 16,
    borderRadius: 12,
    maxWidth: '80%',
  },
  userMessage: {
    alignSelf: 'flex-end',
    backgroundColor: '#1a1a1a',
    marginLeft: 'auto',
  },
  assistantMessage: {
    alignSelf: 'flex-start',
    backgroundColor: '#ffffff',
    borderWidth: 1,
    borderColor: '#f1f3f4',
    marginRight: 'auto',
  },
  messageText: {
    fontSize: 14,
    lineHeight: 20,
    color: '#1a1a1a',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  userMessageText: {
    color: '#ffffff',
  },
  loadingMessage: {
    alignItems: 'center',
    paddingVertical: 12,
  },
  loadingText: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 20,
    backgroundColor: '#ffffff',
    borderTopWidth: 1,
    borderTopColor: '#f1f3f4',
    gap: 12,
  },
  chatInput: {
    flex: 1,
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 24,
    borderWidth: 1,
    borderColor: '#e9ecef',
    fontSize: 14,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
    backgroundColor: '#f8f9fa',
  },
  sendButton: {
    backgroundColor: '#1a1a1a',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 24,
    alignItems: 'center',
    justifyContent: 'center',
    transition: 'all 0.2s ease',
    cursor: 'pointer',
  },
  sendButtonDisabled: {
    backgroundColor: '#ccc',
  },
  sendButtonText: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: '600',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  syllabusSection: {
    marginBottom: 32,
  },
  processedSyllabiSection: {
    marginTop: 24,
  },
  syllabusCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',
  },
  syllabusTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  syllabusProvider: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  syllabusUnit: {
    fontSize: 14,
    color: '#38B6FF',
    marginBottom: 8,
  },
  syllabusPreview: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
  },
  comingSoonSection: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 60,
    paddingHorizontal: 20,
  },
  comingSoonTitle: {
    fontSize: 24,
    fontWeight: '600',
    color: '#333',
    marginBottom: 16,
    textAlign: 'center',
  },
  comingSoonText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    lineHeight: 24,
    maxWidth: 500,
  },
  filterSection: {
    marginBottom: 32,
  },
  filterLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#666666',
    marginBottom: 16,
    textTransform: 'uppercase',
    letterSpacing: '0.5px',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  filterScroll: {
    marginBottom: 8,
  },
  filterChips: {
    flexDirection: 'row',
    gap: 12,
  },
  filterChip: {
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 24,
    backgroundColor: '#f8f9fa',
    borderWidth: 1,
    borderColor: '#e9ecef',
    transition: 'all 0.2s ease',
    cursor: 'pointer',
  },
  filterChipActive: {
    backgroundColor: '#1a1a1a',
    borderColor: '#1a1a1a',
    boxShadow: '0 4px 12px rgba(26, 26, 26, 0.15)',
  },
  filterChipText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#666666',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  filterChipTextActive: {
    color: '#ffffff',
  },
  dashboardGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 16,
    marginBottom: 24,
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 16,
  },
  actionButton: {
    backgroundColor: '#38B6FF',
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 10,
    alignItems: 'center',
    flex: 1,
    marginHorizontal: 5,
  },
  actionButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '600',
  },
  progressSummary: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 16,
  },
  progressItem: {
    alignItems: 'center',
  },
  progressLabel: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  progressValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
  focusContent: {
    marginTop: 16,
  },
  focusText: {
    fontSize: 16,
    color: '#666',
    marginBottom: 8,
  },
  focusSubjects: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  subjectTag: {
    backgroundColor: '#e0e0e0',
    paddingVertical: 6,
    paddingHorizontal: 12,
    borderRadius: 15,
    borderWidth: 1,
    borderColor: '#ccc',
  },
  resourceList: {
    marginTop: 16,
  },
  resourceItem: {
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 10,
    backgroundColor: '#f9f9f9',
    marginBottom: 10,
    alignItems: 'center',
  },
  resourceText: {
    fontSize: 14,
    color: '#333',
  },
  childrenSection: {
    marginBottom: 40,
  },
  childrenGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 24,
  },
  childCard: {
    width: 320,
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 24,
    borderWidth: 1,
    borderColor: '#f1f3f4',
    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04), 0 1px 3px rgba(0, 0, 0, 0.06)',
    transition: 'all 0.2s ease',
    cursor: 'pointer',
  },
  childCardHover: {
    boxShadow: '0 8px 25px rgba(0, 0, 0, 0.08), 0 3px 10px rgba(0, 0, 0, 0.06)',
    transform: 'translateY(-2px)',
  },
  childHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 20,
  },
  childAvatar: {
    width: 48,
    height: 48,
    borderRadius: 24,
    marginRight: 16,
  },
  childInfo: {
    flex: 1,
  },
  childName: {
    fontSize: 20,
    fontWeight: '600',
    color: '#1a1a1a',
    marginBottom: 4,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  childDetails: {
    fontSize: 14,
    color: '#666666',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  childStats: {
    flexDirection: 'row',
    gap: 24,
  },
  statItem: {
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: '700',
    color: '#1a1a1a',
    marginBottom: 4,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  statLabel: {
    fontSize: 12,
    fontWeight: '500',
    color: '#666666',
    textTransform: 'uppercase',
    letterSpacing: '0.5px',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  primaryButton: {
    backgroundColor: '#1a1a1a',
    paddingHorizontal: 32,
    paddingVertical: 16,
    borderRadius: 12,
    transition: 'all 0.2s ease',
    cursor: 'pointer',
  },
  primaryButtonHover: {
    backgroundColor: '#000000',
    transform: 'translateY(-1px)',
    boxShadow: '0 8px 25px rgba(26, 26, 26, 0.25)',
  },
  primaryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
    textAlign: 'center',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  // Update existing card styles to work with new layout
  card: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 20,
    borderWidth: 1,
    borderColor: '#e1e1e1',
    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.05)',
    flex: 1,
    minWidth: 280,
  },
  cardBlue: {
    borderLeftWidth: 4,
    borderLeftColor: '#38B6FF',
  },
  // Today's Learning Styles
  todaysLearningSection: {
    marginTop: 24,
  },
  loadingContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 40,
  },
  loadingText: {
    fontSize: 14,
    color: '#666',
    marginTop: 16,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  childLearningCard: {
    backgroundColor: '#f8fafc',
    borderRadius: 10,
    padding: 15,
    marginBottom: 15,
    borderLeftWidth: 4,
    borderLeftColor: '#38B6FF',
  },
  trackItem: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 12,
    marginBottom: 8,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  trackName: {
    fontSize: 14,
    fontWeight: '500',
    color: '#2d3748',
    marginBottom: 4,
  },
  trackSchedule: {
    fontSize: 12,
    color: '#666',
    marginBottom: 8,
  },
  roadmapPreview: {
    borderTopWidth: 1,
    borderTopColor: '#e2e8f0',
    paddingTop: 8,
  },
  roadmapLabel: {
    fontSize: 11,
    fontWeight: '500',
    color: '#666',
    marginBottom: 4,
    textTransform: 'uppercase',
  },
  roadmapContent: {
    fontSize: 12,
    color: '#38B6FF',
    fontStyle: 'italic',
  },
  noLearningContainer: {
    alignItems: 'center',
    padding: 20,
  },
  noLearningText: {
    fontSize: 16,
    color: '#666',
    marginBottom: 5,
  },
  noLearningSubtext: {
    fontSize: 14,
    color: '#999',
    fontStyle: 'italic',
  },
  cardGreen: {
    borderLeftWidth: 4,
    borderLeftColor: '#4CAF50',
  },
  cardYellow: {
    borderLeftWidth: 4,
    borderLeftColor: '#FFC107',
  },
  cardPink: {
    borderLeftWidth: 4,
    borderLeftColor: '#E91E63',
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 16,
  },
  noDataText: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
    fontStyle: 'italic',
    paddingVertical: 20,
  },
  formContainer: {
    maxWidth: 600,
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 32,
    borderWidth: 1,
    borderColor: '#f1f3f4',
    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
  },
  formTitle: {
    fontSize: 28,
    fontWeight: '600',
    color: '#1a1a1a',
    marginBottom: 8,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  formSubtitle: {
    fontSize: 16,
    color: '#666666',
    marginBottom: 32,
    lineHeight: 24,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  formRow: {
    marginBottom: 24,
  },
  formLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#1a1a1a',
    marginBottom: 8,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  formInput: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e9ecef',
    fontSize: 14,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
    backgroundColor: '#ffffff',
    transition: 'all 0.2s ease',
  },
  formInputFocus: {
    borderColor: '#1a1a1a',
    boxShadow: '0 0 0 3px rgba(26, 26, 26, 0.1)',
  },
  formButton: {
    backgroundColor: '#1a1a1a',
    paddingHorizontal: 24,
    paddingVertical: 14,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    transition: 'all 0.2s ease',
    cursor: 'pointer',
  },
  formButtonHover: {
    backgroundColor: '#000000',
    transform: 'translateY(-1px)',
    boxShadow: '0 4px 12px rgba(26, 26, 26, 0.2)',
  },
  formButtonText: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: '600',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  avatarGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 12,
    marginTop: 8,
  },
  avatarOption: {
    width: 48,
    height: 48,
    borderRadius: 24,
    borderWidth: 2,
    borderColor: '#e9ecef',
    transition: 'all 0.2s ease',
    cursor: 'pointer',
  },
  avatarOptionSelected: {
    borderColor: '#1a1a1a',
    transform: 'scale(1.1)',
  },
  gradeChips: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    marginTop: 8,
  },
  gradeChip: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#e9ecef',
    backgroundColor: '#f8f9fa',
    transition: 'all 0.2s ease',
    cursor: 'pointer',
  },
  gradeChipSelected: {
    backgroundColor: '#1a1a1a',
    borderColor: '#1a1a1a',
  },
  gradeChipText: {
    fontSize: 12,
    fontWeight: '500',
    color: '#666666',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  gradeChipTextSelected: {
    color: '#ffffff',
  },
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 16,
  },
  checkbox: {
    width: 20,
    height: 20,
    borderRadius: 4,
    borderWidth: 2,
    borderColor: '#e9ecef',
    marginRight: 12,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#ffffff',
    transition: 'all 0.2s ease',
    cursor: 'pointer',
  },
  checkboxChecked: {
    backgroundColor: '#1a1a1a',
    borderColor: '#1a1a1a',
  },
  checkboxLabel: {
    fontSize: 14,
    color: '#1a1a1a',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  subjectGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 16,
    marginTop: 16,
  },
  subjectCard: {
    width: 200,
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 20,
    borderWidth: 1,
    borderColor: '#f1f3f4',
    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
    transition: 'all 0.2s ease',
    cursor: 'pointer',
  },
  subjectCardHover: {
    boxShadow: '0 4px 16px rgba(0, 0, 0, 0.08)',
    transform: 'translateY(-2px)',
  },
  subjectName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1a1a1a',
    marginBottom: 8,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  subjectDetails: {
    fontSize: 12,
    color: '#666666',
    marginBottom: 12,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  subjectToggle: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  toggleSwitch: {
    width: 40,
    height: 24,
    borderRadius: 12,
    backgroundColor: '#e9ecef',
    padding: 2,
    transition: 'all 0.2s ease',
    cursor: 'pointer',
  },
  toggleSwitchActive: {
    backgroundColor: '#1a1a1a',
  },
  toggleThumb: {
    width: 20,
    height: 20,
    borderRadius: 10,
    backgroundColor: '#ffffff',
    transition: 'all 0.2s ease',
  },
  toggleThumbActive: {
    transform: 'translateX(16px)',
  },
  aiHelpButton: {
    backgroundColor: '#f8f9fa',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e9ecef',
    alignItems: 'center',
    justifyContent: 'center',
    transition: 'all 0.2s ease',
    cursor: 'pointer',
    marginTop: 16,
  },
  aiHelpButtonHover: {
    backgroundColor: '#e9ecef',
    borderColor: '#1a1a1a',
  },
  aiHelpButtonText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#666666',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  calendarContainer: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    borderWidth: 1,
    borderColor: '#f1f3f4',
    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
    overflow: 'hidden',
  },
  calendarHeader: {
    padding: 24,
    borderBottomWidth: 1,
    borderBottomColor: '#f1f3f4',
    backgroundColor: '#fafbfc',
  },
  calendarTitle: {
    fontSize: 24,
    fontWeight: '600',
    color: '#1a1a1a',
    marginBottom: 8,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  calendarSubtitle: {
    fontSize: 14,
    color: '#666666',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  calendarGrid: {
    padding: 24,
  },
  calendarRow: {
    flexDirection: 'row',
    marginBottom: 8,
  },
  calendarCell: {
    flex: 1,
    paddingVertical: 12,
    paddingHorizontal: 8,
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 8,
    transition: 'all 0.2s ease',
    cursor: 'pointer',
  },
  calendarCellHover: {
    backgroundColor: '#f8f9fa',
  },
  calendarCellToday: {
    backgroundColor: '#1a1a1a',
  },
  calendarCellText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#1a1a1a',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  calendarCellTextToday: {
    color: '#ffffff',
  },
  calendarCellTextOther: {
    color: '#cccccc',
  },
  calendarLegend: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 24,
    marginTop: 24,
    paddingTop: 24,
    borderTopWidth: 1,
    borderTopColor: '#f1f3f4',
  },
  legendItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  legendDot: {
    width: 12,
    height: 12,
    borderRadius: 6,
  },
  legendText: {
    fontSize: 12,
    color: '#666666',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  modalOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 1000,
  },
  modalContent: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 32,
    maxWidth: 500,
    width: '90%',
    maxHeight: '80%',
    borderWidth: 1,
    borderColor: '#f1f3f4',
    boxShadow: '0 20px 60px rgba(0, 0, 0, 0.3)',
  },
  modalTitle: {
    fontSize: 24,
    fontWeight: '600',
    color: '#1a1a1a',
    marginBottom: 16,
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  modalClose: {
    position: 'absolute',
    top: 20,
    right: 20,
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#f8f9fa',
    alignItems: 'center',
    justifyContent: 'center',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
  },
  modalCloseHover: {
    backgroundColor: '#e9ecef',
  },
  modalCloseText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#666666',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  quickActions: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 16,
    marginTop: 24,
  },
  quickAction: {
    backgroundColor: '#f8f9fa',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e9ecef',
    transition: 'all 0.2s ease',
    cursor: 'pointer',
  },
  quickActionHover: {
    backgroundColor: '#e9ecef',
    borderColor: '#1a1a1a',
    transform: 'translateY(-1px)',
  },
  quickActionText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#666666',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  errorContainer: {
    backgroundColor: '#fef2f2',
    borderWidth: 1,
    borderColor: '#fecaca',
    borderRadius: 8,
    padding: 16,
    marginBottom: 24,
  },
  errorText: {
    fontSize: 14,
    color: '#dc2626',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  successContainer: {
    backgroundColor: '#f0fdf4',
    borderWidth: 1,
    borderColor: '#bbf7d0',
    borderRadius: 8,
    padding: 16,
    marginBottom: 24,
  },
  successText: {
    fontSize: 14,
    color: '#16a34a',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  
  // Calendar Chip Styles
  calendarChips: {
    flexDirection: 'column',
    justifyContent: 'flex-start',
    gap: 1,
    marginTop: 2,
    maxHeight: 90,
    overflow: 'hidden',
  },
  eventChip: {
    borderRadius: 6,
    paddingHorizontal: 4,
    paddingVertical: 1,
    minWidth: '100%',
    maxWidth: '100%',
    alignItems: 'flex-start',
    borderWidth: 1,
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    marginBottom: 1,
  },
  chipToday: {
    backgroundColor: 'rgba(16, 185, 129, 0.2)',
    borderRadius: 8,
    paddingHorizontal: 4,
    paddingVertical: 2,
    minWidth: 16,
    alignItems: 'flex-start',
    borderWidth: 1,
    borderColor: 'rgba(16, 185, 129, 0.3)',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
  },
  chipLesson: {
    backgroundColor: 'rgba(59, 130, 246, 0.2)',
    borderRadius: 8,
    paddingHorizontal: 4,
    paddingVertical: 2,
    minWidth: 16,
    alignItems: 'flex-start',
    borderWidth: 1,
    borderColor: 'rgba(59, 130, 246, 0.3)',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
  },
  chipActivity: {
    backgroundColor: 'rgba(245, 158, 11, 0.2)',
    borderRadius: 8,
    paddingHorizontal: 4,
    paddingVertical: 2,
    minWidth: 16,
    alignItems: 'flex-start',
    borderWidth: 1,
    borderColor: 'rgba(245, 158, 11, 0.3)',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
  },
  chipHoliday: {
    backgroundColor: 'rgba(239, 68, 68, 0.2)',
    borderRadius: 8,
    paddingHorizontal: 4,
    paddingVertical: 2,
    minWidth: 16,
    alignItems: 'flex-start',
    borderWidth: 1,
    borderColor: 'rgba(239, 68, 68, 0.3)',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
  },
  chipText: {
    fontSize: 9,
    color: '#374151',
    fontWeight: '600',
    textAlign: 'left',
    lineHeight: 11,
  },
  chipSubtext: {
    fontSize: 7,
    color: '#6b7280',
    fontWeight: '500',
    textAlign: 'left',
    marginTop: 1,
    lineHeight: 9,
  },
  
  // Hover effects for web
  chipHover: {
    transform: 'scale(1.1)',
    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)',
  },
  
  // Loading spinner animation
  loadingSpinner: {
    width: 40,
    height: 40,
    borderRadius: 20,
    borderWidth: 3,
    borderColor: '#e5e7eb',
    borderTopColor: '#3b82f6',
  },
  
  // Mini Calendar Chip Styles - Removed since chips are no longer shown
  
  // Calendar Legend and Controls Styles - Removed for cleaner interface


}) 